<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/LRS.js - TinCanJS</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="http://cdn4.tincanapi.com/wp-content/themes/tincanapi/images/logo.png" title="TinCanJS"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.50.0</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/TinCan.html">TinCan</a></li>
            
                <li><a href="../classes/TinCan.About.html">TinCan.About</a></li>
            
                <li><a href="../classes/TinCan.Activity.html">TinCan.Activity</a></li>
            
                <li><a href="../classes/TinCan.ActivityDefinition.html">TinCan.ActivityDefinition</a></li>
            
                <li><a href="../classes/TinCan.ActivityProfile.html">TinCan.ActivityProfile</a></li>
            
                <li><a href="../classes/TinCan.Agent.html">TinCan.Agent</a></li>
            
                <li><a href="../classes/TinCan.AgentAccount.html">TinCan.AgentAccount</a></li>
            
                <li><a href="../classes/TinCan.AgentProfile.html">TinCan.AgentProfile</a></li>
            
                <li><a href="../classes/TinCan.Attachment.html">TinCan.Attachment</a></li>
            
                <li><a href="../classes/TinCan.Context.html">TinCan.Context</a></li>
            
                <li><a href="../classes/TinCan.ContextActivities.html">TinCan.ContextActivities</a></li>
            
                <li><a href="../classes/TinCan.Group.html">TinCan.Group</a></li>
            
                <li><a href="../classes/TinCan.InteractionComponent.html">TinCan.InteractionComponent</a></li>
            
                <li><a href="../classes/TinCan.LRS.html">TinCan.LRS</a></li>
            
                <li><a href="../classes/TinCan.Result.html">TinCan.Result</a></li>
            
                <li><a href="../classes/TinCan.Score.html">TinCan.Score</a></li>
            
                <li><a href="../classes/TinCan.State.html">TinCan.State</a></li>
            
                <li><a href="../classes/TinCan.Statement.html">TinCan.Statement</a></li>
            
                <li><a href="../classes/TinCan.StatementRef.html">TinCan.StatementRef</a></li>
            
                <li><a href="../classes/TinCan.StatementsResult.html">TinCan.StatementsResult</a></li>
            
                <li><a href="../classes/TinCan.SubStatement.html">TinCan.SubStatement</a></li>
            
                <li><a href="../classes/TinCan.Utils.html">TinCan.Utils</a></li>
            
                <li><a href="../classes/TinCan.Verb.html">TinCan.Verb</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/TinCan.html">TinCan</a></li>
            
                <li><a href="../modules/TinCan.About.html">TinCan.About</a></li>
            
                <li><a href="../modules/TinCan.Activity.html">TinCan.Activity</a></li>
            
                <li><a href="../modules/TinCan.ActivityDefinition.html">TinCan.ActivityDefinition</a></li>
            
                <li><a href="../modules/TinCan.ActivityProfile.html">TinCan.ActivityProfile</a></li>
            
                <li><a href="../modules/TinCan.Agent.html">TinCan.Agent</a></li>
            
                <li><a href="../modules/TinCan.AgentAccount.html">TinCan.AgentAccount</a></li>
            
                <li><a href="../modules/TinCan.AgentProfile.html">TinCan.AgentProfile</a></li>
            
                <li><a href="../modules/TinCan.Attachment.html">TinCan.Attachment</a></li>
            
                <li><a href="../modules/TinCan.Context.html">TinCan.Context</a></li>
            
                <li><a href="../modules/TinCan.ContextActivities.html">TinCan.ContextActivities</a></li>
            
                <li><a href="../modules/TinCan.Environment.Browser.html">TinCan.Environment.Browser</a></li>
            
                <li><a href="../modules/TinCan.Environment.Node.html">TinCan.Environment.Node</a></li>
            
                <li><a href="../modules/TinCan.Group.html">TinCan.Group</a></li>
            
                <li><a href="../modules/TinCan.InteractionComponent.html">TinCan.InteractionComponent</a></li>
            
                <li><a href="../modules/TinCan.LRS.html">TinCan.LRS</a></li>
            
                <li><a href="../modules/TinCan.Result.html">TinCan.Result</a></li>
            
                <li><a href="../modules/TinCan.Score.html">TinCan.Score</a></li>
            
                <li><a href="../modules/TinCan.State.html">TinCan.State</a></li>
            
                <li><a href="../modules/TinCan.Statement.html">TinCan.Statement</a></li>
            
                <li><a href="../modules/TinCan.StatementRef.html">TinCan.StatementRef</a></li>
            
                <li><a href="../modules/TinCan.StatementsResult.html">TinCan.StatementsResult</a></li>
            
                <li><a href="../modules/TinCan.SubStatement.html">TinCan.SubStatement</a></li>
            
                <li><a href="../modules/TinCan.Utils.html">TinCan.Utils</a></li>
            
                <li><a href="../modules/TinCan.Verb.html">TinCan.Verb</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: src/LRS.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/*
    Copyright 2012-2013 Rustici Software

    Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
*/

/**
TinCan client library

@module TinCan
@submodule TinCan.LRS
**/
(function () {
    &quot;use strict&quot;;
    /**
    @class TinCan.LRS
    @constructor
    */
    var LRS = TinCan.LRS = function (cfg) {
        this.log(&quot;constructor&quot;);

        /**
        @property endpoint
        @type String
        */
        this.endpoint = null;

        /**
        @property version
        @type String
        */
        this.version = null;

        /**
        @property auth
        @type String
        */
        this.auth = null;

        /**
        @property allowFail
        @type Boolean
        @default true
        */
        this.allowFail = true;

        /**
        @property extended
        @type Object
        */
        this.extended = null;

        this.init(cfg);
    };
    LRS.prototype = {
        /**
        @property LOG_SRC
        */
        LOG_SRC: &quot;LRS&quot;,

        /**
        @method log
        */
        log: TinCan.prototype.log,

        /**
        @method init
        */
        init: function (cfg) {
            this.log(&quot;init&quot;);

            var versions = TinCan.versions(),
                versionMatch = false,
                i
            ;

            cfg = cfg || {};

            if (cfg.hasOwnProperty(&quot;alertOnRequestFailure&quot;)) {
                this.log(&quot;&#x27;alertOnRequestFailure&#x27; is deprecated (alerts have been removed) no need to set it now&quot;);
            }

            if (! cfg.hasOwnProperty(&quot;endpoint&quot;) || cfg.endpoint === null || cfg.endpoint === &quot;&quot;) {
                this.log(&quot;[error] LRS invalid: no endpoint&quot;);
                throw {
                    code: 3,
                    mesg: &quot;LRS invalid: no endpoint&quot;
                };
            }

            this.endpoint = String(cfg.endpoint);
            if (this.endpoint.slice(-1) !== &quot;/&quot;) {
                this.log(&quot;adding trailing slash to endpoint&quot;);
                this.endpoint += &quot;/&quot;;
            }

            if (cfg.hasOwnProperty(&quot;allowFail&quot;)) {
                this.allowFail = cfg.allowFail;
            }

            if (cfg.hasOwnProperty(&quot;auth&quot;)) {
                this.auth = cfg.auth;
            }
            else if (cfg.hasOwnProperty(&quot;username&quot;) &amp;&amp; cfg.hasOwnProperty(&quot;password&quot;)) {
                this.auth = &quot;Basic &quot; + TinCan.Utils.getBase64String(cfg.username + &quot;:&quot; + cfg.password);
            }

            if (cfg.hasOwnProperty(&quot;extended&quot;)) {
                this.extended = cfg.extended;
            }

            //
            // provide a hook method that environments can override
            // to handle anything necessary in the initialization
            // process that is customized to them, such as cross domain
            // setup in browsers, default implementation is empty
            //
            // this hook must run prior to version detection so that
            // request handling can be set up before requesting the
            // LRS version via the /about resource
            //
            this._initByEnvironment(cfg);

            if (typeof cfg.version !== &quot;undefined&quot;) {
                this.log(&quot;version: &quot; + cfg.version);
                for (i = 0; i &lt; versions.length; i += 1) {
                    if (versions[i] === cfg.version) {
                        versionMatch = true;
                        break;
                    }
                }
                if (! versionMatch) {
                    this.log(&quot;[error] LRS invalid: version not supported (&quot; + cfg.version + &quot;)&quot;);
                    throw {
                        code: 5,
                        mesg: &quot;LRS invalid: version not supported (&quot; + cfg.version + &quot;)&quot;
                    };
                }
                this.version = cfg.version;
            }
            else {
                //
                // assume max supported when not specified,
                // TODO: add detection of LRS from call to endpoint
                //
                this.version = versions[0];
            }
        },

        /**
        Creates and returns a boundary for separating parts in
        requests where the statement has an attachment

        @method _getBoundary
        @private
        */
        _getBoundary: function () {
            return TinCan.Utils.getUUID().replace(/-/g, &quot;&quot;);
        },

        /**
        Method should be overloaded by an environment to do per
        environment specifics such that the LRS can make a call
        to set the version if not provided

        @method _initByEnvironment
        @private
        */
        _initByEnvironment: function () {
            this.log(&quot;_initByEnvironment not overloaded - no environment loaded?&quot;);
        },

        /**
        Method should be overloaded by an environment to do per
        environment specifics for sending requests to the LRS

        @method _makeRequest
        @private
        */
        _makeRequest: function () {
            this.log(&quot;_makeRequest not overloaded - no environment loaded?&quot;);
        },

        /**
        Method should be overloaded by an environment to do per
        environment specifics for building multipart request data

        @method _getMultipartRequestData
        @private
        */
        _getMultipartRequestData: function () {
            this.log(&quot;_getMultipartRequestData not overloaded - no environment loaded?&quot;);
        },

        /**
        Method is overloaded by the browser environment in order to test converting an
        HTTP request that is greater than a defined length

        @method _IEModeConversion
        @private
        */
        _IEModeConversion: function () {
            this.log(&quot;_IEModeConversion not overloaded - browser environment not loaded.&quot;);
        },

        _processGetStatementResult: function (xhr, params) {
            var boundary,
                parsedResponse,
                statement,
                attachmentMap = {},
                i;

            if (! params.attachments) {
                return TinCan.Statement.fromJSON(xhr.responseText);
            }

            boundary = xhr.getResponseHeader(&quot;Content-Type&quot;).split(&quot;boundary=&quot;)[1];

            parsedResponse = this._parseMultipart(boundary, xhr.response);
            statement = JSON.parse(parsedResponse[0].body);
            for (i = 1; i &lt; parsedResponse.length; i += 1) {
                attachmentMap[parsedResponse[i].headers[&quot;X-Experience-API-Hash&quot;]] = parsedResponse[i].body;
            }

            this._assignAttachmentContent([statement], attachmentMap);

            return new TinCan.Statement(statement);
        },

        /**
        Method used to send a request via browser objects to the LRS

        @method sendRequest
        @param {Object} cfg Configuration for request
            @param {String} cfg.url URL portion to add to endpoint
            @param {String} [cfg.method] GET, PUT, POST, etc.
            @param {Object} [cfg.params] Parameters to set on the querystring
            @param {String|ArrayBuffer} [cfg.data] Body content as a String or ArrayBuffer
            @param {Object} [cfg.headers] Additional headers to set in the request
            @param {Function} [cfg.callback] Function to run at completion
                @param {String|Null} cfg.callback.err If an error occurred, this parameter will contain the HTTP status code.
                    If the operation succeeded, err will be null.
                @param {Object} cfg.callback.xhr XHR object
            @param {Boolean} [cfg.ignore404] Whether 404 status codes should be considered an error
            @param {Boolean} [cfg.expectMultipart] Whether to expect the response to be a multipart response
        @return {Object} XHR if called in a synchronous way (in other words no callback)
        */
        sendRequest: function (cfg) {
            this.log(&quot;sendRequest&quot;);
            var fullUrl = this.endpoint + cfg.url,
                headers = {},
                prop
            ;

            // respect absolute URLs passed in
            if (cfg.url.indexOf(&quot;http&quot;) === 0) {
                fullUrl = cfg.url;
            }

            // add extended LMS-specified values to the params
            if (this.extended !== null) {
                cfg.params = cfg.params || {};

                for (prop in this.extended) {
                    if (this.extended.hasOwnProperty(prop)) {
                        // don&#x27;t overwrite cfg.params values that have already been added to the request with our extended params
                        if (! cfg.params.hasOwnProperty(prop)) {
                            if (this.extended[prop] !== null) {
                                cfg.params[prop] = this.extended[prop];
                            }
                        }
                    }
                }
            }

            // consolidate headers
            headers.Authorization = this.auth;
            if (this.version !== &quot;0.9&quot;) {
                headers[&quot;X-Experience-API-Version&quot;] = this.version;
            }

            for (prop in cfg.headers) {
                if (cfg.headers.hasOwnProperty(prop)) {
                    headers[prop] = cfg.headers[prop];
                }
            }

            return this._makeRequest(fullUrl, headers, cfg);
        },

        /**
        Method used to determine the LRS version

        @method about
        @param {Object} cfg Configuration object for the about request
            @param {Function} [cfg.callback] Callback to execute upon receiving a response
            @param {Object} [cfg.params] this is needed, but can be empty
        @return {Object} About which holds the version, or asyncrhonously calls a specified callback
        */
        about: function (cfg) {
            this.log(&quot;about&quot;);
            var requestCfg,
                requestResult,
                callbackWrapper;

            cfg = cfg || {};

            requestCfg = {
                url: &quot;about&quot;,
                method: &quot;GET&quot;,
                params: {}
            };
            if (typeof cfg.callback !== &quot;undefined&quot;) {
                callbackWrapper = function (err, xhr) {
                    var result = xhr;

                    if (err === null) {
                        result = TinCan.About.fromJSON(xhr.responseText);
                    }

                    cfg.callback(err, result);
                };
                requestCfg.callback = callbackWrapper;
            }

            requestResult = this.sendRequest(requestCfg);

            if (callbackWrapper) {
                return;
            }

            if (requestResult.err === null) {
                requestResult.xhr = TinCan.About.fromJSON(requestResult.xhr.responseText);
            }
            return requestResult;
        },

        /**
        Save a statement, when used from a browser sends to the endpoint using the RESTful interface.
        Use a callback to make the call asynchronous.

        @method saveStatement
        @param {TinCan.Statement} statement to send
        @param {Object} [cfg] Configuration used when saving
            @param {Function} [cfg.callback] Callback to execute on completion
        */
        saveStatement: function (stmt, cfg) {
            this.log(&quot;saveStatement&quot;);
            var requestCfg = {
                    url: &quot;statements&quot;,
                    headers: {}
                },
                versionedStatement,
                requestAttachments = [],
                boundary,
                i;

            cfg = cfg || {};

            try {
                versionedStatement = stmt.asVersion( this.version );
            }
            catch (ex) {
                if (this.allowFail) {
                    this.log(&quot;[warning] statement could not be serialized in version (&quot; + this.version + &quot;): &quot; + ex);
                    if (typeof cfg.callback !== &quot;undefined&quot;) {
                        cfg.callback(null, null);
                        return;
                    }
                    return {
                        err: null,
                        xhr: null
                    };
                }

                this.log(&quot;[error] statement could not be serialized in version (&quot; + this.version + &quot;): &quot; + ex);
                if (typeof cfg.callback !== &quot;undefined&quot;) {
                    cfg.callback(ex, null);
                    return;
                }
                return {
                    err: ex,
                    xhr: null
                };
            }

            if (versionedStatement.hasOwnProperty(&quot;attachments&quot;) &amp;&amp; stmt.hasAttachmentWithContent()) {
                boundary = this._getBoundary();

                requestCfg.headers[&quot;Content-Type&quot;] = &quot;multipart/mixed; boundary=&quot; + boundary;

                for (i = 0; i &lt; stmt.attachments.length; i += 1) {
                    if (stmt.attachments[i].content !== null) {
                        requestAttachments.push(stmt.attachments[i]);
                    }
                }

                try {
                    requestCfg.data = this._getMultipartRequestData(boundary, versionedStatement, requestAttachments);
                }
                catch (ex) {
                    if (this.allowFail) {
                        this.log(&quot;[warning] multipart request data could not be created (attachments probably not supported): &quot; + ex);
                        if (typeof cfg.callback !== &quot;undefined&quot;) {
                            cfg.callback(null, null);
                            return;
                        }
                        return {
                            err: null,
                            xhr: null
                        };
                    }

                    this.log(&quot;[error] multipart request data could not be created (attachments probably not supported): &quot; + ex);
                    if (typeof cfg.callback !== &quot;undefined&quot;) {
                        cfg.callback(ex, null);
                        return;
                    }
                    return {
                        err: ex,
                        xhr: null
                    };
                }
            }
            else {
                requestCfg.headers[&quot;Content-Type&quot;] = &quot;application/json&quot;;
                requestCfg.data = JSON.stringify(versionedStatement);
            }
            if (stmt.id !== null) {
                requestCfg.method = &quot;PUT&quot;;
                requestCfg.params = {
                    statementId: stmt.id
                };
            }
            else {
                requestCfg.method = &quot;POST&quot;;
            }

            if (typeof cfg.callback !== &quot;undefined&quot;) {
                requestCfg.callback = cfg.callback;
            }

            return this.sendRequest(requestCfg);
        },

        /**
        Retrieve a statement, when used from a browser sends to the endpoint using the RESTful interface.

        @method retrieveStatement
        @param {String} ID of statement to retrieve
        @param {Object} [cfg] Configuration options
            @param {Object} [cfg.params] Query parameters
                @param {Boolean} [cfg.params.attachments] Include attachments in multipart response or don&#x27;t (default: false)
            @param {Function} [cfg.callback] Callback to execute on completion
        @return {TinCan.Statement} Statement retrieved
        */
        retrieveStatement: function (stmtId, cfg) {
            this.log(&quot;retrieveStatement&quot;);
            var requestCfg,
                requestResult,
                callbackWrapper,
                lrs = this;

            cfg = cfg || {};
            cfg.params = cfg.params || {};

            requestCfg = {
                url: &quot;statements&quot;,
                method: &quot;GET&quot;,
                params: {
                    statementId: stmtId
                }
            };
            if (cfg.params.attachments) {
                requestCfg.params.attachments = true;
                requestCfg.expectMultipart = true;
            }
            if (typeof cfg.callback !== &quot;undefined&quot;) {
                callbackWrapper = function (err, xhr) {
                    var result = xhr;

                    if (err === null) {
                        result = lrs._processGetStatementResult(xhr, cfg.params);
                    }

                    cfg.callback(err, result);
                };
                requestCfg.callback = callbackWrapper;
            }

            requestResult = this.sendRequest(requestCfg);
            if (! callbackWrapper) {
                requestResult.statement = null;
                if (requestResult.err === null) {
                    requestResult.statement = lrs._processGetStatementResult(requestResult.xhr, cfg.params);
                }
            }

            return requestResult;
        },

        /**
        Retrieve a voided statement, when used from a browser sends to the endpoint using the RESTful interface.

        @method retrieveVoidedStatement
        @param {String} ID of voided statement to retrieve
        @param {Object} [cfg] Configuration options
            @param {Object} [cfg.params] Query parameters
                @param {Boolean} [cfg.params.attachments] Include attachments in multipart response or don&#x27;t (default: false)
            @param {Function} [cfg.callback] Callback to execute on completion
        @return {TinCan.Statement} Statement retrieved
        */
        retrieveVoidedStatement: function (stmtId, cfg) {
            this.log(&quot;retrieveVoidedStatement&quot;);
            var requestCfg,
                requestResult,
                callbackWrapper,
                lrs = this;

            cfg = cfg || {};
            cfg.params = cfg.params || {};

            requestCfg = {
                url: &quot;statements&quot;,
                method: &quot;GET&quot;,
                params: {}
            };
            if (this.version === &quot;0.9&quot; || this.version === &quot;0.95&quot;) {
                requestCfg.params.statementId = stmtId;
            }
            else {
                requestCfg.params.voidedStatementId = stmtId;
                if (cfg.params.attachments) {
                    requestCfg.params.attachments = true;
                    requestCfg.expectMultipart = true;
                }
            }

            if (typeof cfg.callback !== &quot;undefined&quot;) {
                callbackWrapper = function (err, xhr) {
                    var result = xhr;

                    if (err === null) {
                        result = lrs._processGetStatementResult(xhr, cfg.params);
                    }

                    cfg.callback(err, result);
                };
                requestCfg.callback = callbackWrapper;
            }

            requestResult = this.sendRequest(requestCfg);
            if (! callbackWrapper) {
                requestResult.statement = null;
                if (requestResult.err === null) {
                    requestResult.statement = lrs._processGetStatementResult(requestResult.xhr, cfg.params);
                }
            }

            return requestResult;
        },

        /**
        Save a set of statements, when used from a browser sends to the endpoint using the RESTful interface.
        Use a callback to make the call asynchronous.

        @method saveStatements
        @param {Array} Array of statements or objects convertable to statements
        @param {Object} [cfg] Configuration used when saving
            @param {Function} [cfg.callback] Callback to execute on completion
        */
        saveStatements: function (stmts, cfg) {
            this.log(&quot;saveStatements&quot;);
            var requestCfg = {
                    url: &quot;statements&quot;,
                    method: &quot;POST&quot;,
                    headers: {}
                },
                versionedStatement,
                versionedStatements = [],
                requestAttachments = [],
                boundary,
                i,
                j;

            cfg = cfg || {};

            if (stmts.length === 0) {
                if (typeof cfg.callback !== &quot;undefined&quot;) {
                    cfg.callback(new Error(&quot;no statements&quot;), null);
                    return;
                }
                return {
                    err: new Error(&quot;no statements&quot;),
                    xhr: null
                };
            }

            for (i = 0; i &lt; stmts.length; i += 1) {
                try {
                    versionedStatement = stmts[i].asVersion( this.version );
                }
                catch (ex) {
                    if (this.allowFail) {
                        this.log(&quot;[warning] statement could not be serialized in version (&quot; + this.version + &quot;): &quot; + ex);
                        if (typeof cfg.callback !== &quot;undefined&quot;) {
                            cfg.callback(null, null);
                            return;
                        }
                        return {
                            err: null,
                            xhr: null
                        };
                    }

                    this.log(&quot;[error] statement could not be serialized in version (&quot; + this.version + &quot;): &quot; + ex);
                    if (typeof cfg.callback !== &quot;undefined&quot;) {
                        cfg.callback(ex, null);
                        return;
                    }
                    return {
                        err: ex,
                        xhr: null
                    };
                }

                if (stmts[i].hasAttachmentWithContent()) {
                    for (j = 0; j &lt; stmts[i].attachments.length; j += 1) {
                        if (stmts[i].attachments[j].content !== null) {
                            requestAttachments.push(stmts[i].attachments[j]);
                        }
                    }
                }

                versionedStatements.push(versionedStatement);
            }

            if (requestAttachments.length !== 0) {
                boundary = this._getBoundary();

                requestCfg.headers[&quot;Content-Type&quot;] = &quot;multipart/mixed; boundary=&quot; + boundary;

                try {
                    requestCfg.data = this._getMultipartRequestData(boundary, versionedStatements, requestAttachments);
                }
                catch (ex) {
                    if (this.allowFail) {
                        this.log(&quot;[warning] multipart request data could not be created (attachments probably not supported): &quot; + ex);
                        if (typeof cfg.callback !== &quot;undefined&quot;) {
                            cfg.callback(null, null);
                            return;
                        }
                        return {
                            err: null,
                            xhr: null
                        };
                    }

                    this.log(&quot;[error] multipart request data could not be created (attachments probably not supported): &quot; + ex);
                    if (typeof cfg.callback !== &quot;undefined&quot;) {
                        cfg.callback(ex, null);
                        return;
                    }
                    return {
                        err: ex,
                        xhr: null
                    };
                }
            }
            else {
                requestCfg.headers[&quot;Content-Type&quot;] = &quot;application/json&quot;;
                requestCfg.data = JSON.stringify(versionedStatements);
            }

            if (typeof cfg.callback !== &quot;undefined&quot;) {
                requestCfg.callback = cfg.callback;
            }

            return this.sendRequest(requestCfg);
        },

        /**
        Fetch a set of statements, when used from a browser sends to the endpoint using the
        RESTful interface.  Use a callback to make the call asynchronous.

        @method queryStatements
        @param {Object} [cfg] Configuration used to query
            @param {Object} [cfg.params] Query parameters
                @param {TinCan.Agent|TinCan.Group} [cfg.params.agent] Agent matches &#x27;actor&#x27; or &#x27;object&#x27;
                @param {TinCan.Verb|String} [cfg.params.verb] Verb (or verb ID) to query on
                @param {TinCan.Activity|String} [cfg.params.activity] Activity (or activity ID) to query on
                @param {String} [cfg.params.registration] Registration UUID
                @param {Boolean} [cfg.params.related_activities] Match related activities
                @param {Boolean} [cfg.params.related_agents] Match related agents
                @param {String} [cfg.params.since] Match statements stored since specified timestamp
                @param {String} [cfg.params.until] Match statements stored at or before specified timestamp
                @param {Integer} [cfg.params.limit] Number of results to retrieve
                @param {String} [cfg.params.format] One of &quot;ids&quot;, &quot;exact&quot;, &quot;canonical&quot; (default: &quot;exact&quot;)
                @param {Boolean} [cfg.params.ascending] Return results in ascending order of stored time

                @param {TinCan.Agent} [cfg.params.actor] (Removed in 1.0.0, use &#x27;agent&#x27; instead) Agent matches &#x27;actor&#x27;
                @param {TinCan.Activity|TinCan.Agent|TinCan.Statement} [cfg.params.target] (Removed in 1.0.0, use &#x27;activity&#x27; or &#x27;agent&#x27; instead) Activity, Agent, or Statement matches &#x27;object&#x27;
                @param {TinCan.Agent} [cfg.params.instructor] (Removed in 1.0.0, use &#x27;agent&#x27; + &#x27;related_agents&#x27; instead) Agent matches &#x27;context:instructor&#x27;
                @param {Boolean} [cfg.params.context] (Removed in 1.0.0, use &#x27;activity&#x27; instead) When filtering on target, include statements with matching context
                @param {Boolean} [cfg.params.authoritative] (Removed in 1.0.0) Get authoritative results
                @param {Boolean} [cfg.params.sparse] (Removed in 1.0.0, use &#x27;format&#x27; instead) Get sparse results

            @param {Function} [cfg.callback] Callback to execute on completion
                @param {String|null} cfg.callback.err Error status or null if succcess
                @param {TinCan.StatementsResult|XHR} cfg.callback.response Receives a StatementsResult argument
        @return {Object} Request result
        */
        queryStatements: function (cfg) {
            this.log(&quot;queryStatements&quot;);
            var requestCfg,
                requestResult,
                callbackWrapper,
                lrs = this;

            cfg = cfg || {};
            cfg.params = cfg.params || {};

            //
            // if they misconfigured (possibly due to version mismatches) the
            // query then don&#x27;t try to send a request at all, rather than give
            // them invalid results
            //
            try {
                requestCfg = this._queryStatementsRequestCfg(cfg);

                if (cfg.params.attachments) {
                    requestCfg.expectMultipart = true;
                }
            }
            catch (ex) {
                this.log(&quot;[error] Query statements failed - &quot; + ex);
                if (typeof cfg.callback !== &quot;undefined&quot;) {
                    cfg.callback(ex, {});
                }

                return {
                    err: ex,
                    statementsResult: null
                };
            }

            if (typeof cfg.callback !== &quot;undefined&quot;) {
                callbackWrapper = function (err, xhr) {
                    var result = xhr,
                        parsedResponse,
                        boundary,
                        statements,
                        attachmentMap = {},
                        i;

                    if (err === null) {
                        if (! cfg.params.attachments) {
                            result = TinCan.StatementsResult.fromJSON(xhr.responseText);
                        }
                        else {
                            boundary = xhr.getResponseHeader(&quot;Content-Type&quot;).split(&quot;boundary=&quot;)[1];

                            parsedResponse = lrs._parseMultipart(boundary, xhr.response);
                            statements = JSON.parse(parsedResponse[0].body);
                            for (i = 1; i &lt; parsedResponse.length; i += 1) {
                                attachmentMap[parsedResponse[i].headers[&quot;X-Experience-API-Hash&quot;]] = parsedResponse[i].body;
                            }

                            lrs._assignAttachmentContent(statements.statements, attachmentMap);
                            result = new TinCan.StatementsResult({ statements: statements.statements });

                            for (i = 0; i &lt; result.statements.length; i += 1) {
                                if (! (result.statements[i] instanceof TinCan.Statement)) {
                                    result.statements[i] = new TinCan.Statement(result.statements[i]);
                                }
                            }
                        }
                    }

                    cfg.callback(err, result);
                };
                requestCfg.callback = callbackWrapper;
            }

            requestResult = this.sendRequest(requestCfg);
            requestResult.config = requestCfg;

            if (! callbackWrapper) {
                requestResult.statementsResult = null;
                if (requestResult.err === null) {
                    requestResult.statementsResult = TinCan.StatementsResult.fromJSON(requestResult.xhr.responseText);
                }
            }

            return requestResult;
        },

        /**
        Build a request config object that can be passed to sendRequest() to make a query request

        @method _queryStatementsRequestCfg
        @private
        @param {Object} [cfg] See configuration for {{#crossLink &quot;TinCan.LRS/queryStatements&quot;}}{{/crossLink}}
        @return {Object} Request configuration object
        */
        _queryStatementsRequestCfg: function (cfg) {
            this.log(&quot;_queryStatementsRequestCfg&quot;);
            var params = {},
                returnCfg = {
                    url: &quot;statements&quot;,
                    method: &quot;GET&quot;,
                    params: params
                },
                jsonProps = [
                    &quot;agent&quot;,
                    &quot;actor&quot;,
                    &quot;object&quot;,
                    &quot;instructor&quot;
                ],
                idProps = [
                    &quot;verb&quot;,
                    &quot;activity&quot;
                ],
                valProps = [
                    &quot;registration&quot;,
                    &quot;context&quot;,
                    &quot;since&quot;,
                    &quot;until&quot;,
                    &quot;limit&quot;,
                    &quot;authoritative&quot;,
                    &quot;sparse&quot;,
                    &quot;ascending&quot;,
                    &quot;related_activities&quot;,
                    &quot;related_agents&quot;,
                    &quot;format&quot;,
                    &quot;attachments&quot;
                ],
                i,
                prop,
                //
                // list of parameters that are supported in all versions (supported by
                // this library) of the spec
                //
                universal = {
                    verb: true,
                    registration: true,
                    since: true,
                    until: true,
                    limit: true,
                    ascending: true
                },
                //
                // future proofing here, &quot;supported&quot; is an object so that
                // in the future we can support a &quot;deprecated&quot; list to
                // throw warnings, hopefully the spec uses deprecation phases
                // for the removal of these things
                //
                compatibility = {
                    &quot;0.9&quot;: {
                        supported: {
                            actor: true,
                            instructor: true,
                            target: true,
                            object: true,
                            context: true,
                            authoritative: true,
                            sparse: true
                        }
                    },
                    &quot;1.0.0&quot;: {
                        supported: {
                            agent: true,
                            activity: true,
                            related_activities: true,
                            related_agents: true,
                            format: true,
                            attachments: true
                        }
                    }
                };

            compatibility[&quot;0.95&quot;] = compatibility[&quot;0.9&quot;];
            compatibility[&quot;1.0.1&quot;] = compatibility[&quot;1.0.0&quot;];
            compatibility[&quot;1.0.2&quot;] = compatibility[&quot;1.0.0&quot;];

            if (cfg.params.hasOwnProperty(&quot;target&quot;)) {
                cfg.params.object = cfg.params.target;
            }

            //
            // check compatibility tables, either the configured parameter is in
            // the universal list or the specific version, if not then throw an
            // error which at least for .queryStatements will prevent the request
            // and potentially alert the user
            //
            for (prop in cfg.params) {
                if (cfg.params.hasOwnProperty(prop)) {
                    if (typeof universal[prop] === &quot;undefined&quot; &amp;&amp; typeof compatibility[this.version].supported[prop] === &quot;undefined&quot;) {
                        throw &quot;Unrecognized query parameter configured: &quot; + prop;
                    }
                }
            }

            //
            // getting here means that all parameters are valid for this version
            // to make handling the output formats easier
            //

            for (i = 0; i &lt; jsonProps.length; i += 1) {
                if (typeof cfg.params[jsonProps[i]] !== &quot;undefined&quot;) {
                    params[jsonProps[i]] = JSON.stringify(cfg.params[jsonProps[i]].asVersion(this.version));
                }
            }

            for (i = 0; i &lt; idProps.length; i += 1) {
                if (typeof cfg.params[idProps[i]] !== &quot;undefined&quot;) {
                    if (typeof cfg.params[idProps[i]].id === &quot;undefined&quot;) {
                        params[idProps[i]] = cfg.params[idProps[i]];
                    }
                    else {
                        params[idProps[i]] = cfg.params[idProps[i]].id;
                    }
                }
            }

            for (i = 0; i &lt; valProps.length; i += 1) {
                if (typeof cfg.params[valProps[i]] !== &quot;undefined&quot; &amp;&amp; cfg.params[valProps[i]] !== null) {
                    params[valProps[i]] = cfg.params[valProps[i]];
                }
            }

            return returnCfg;
        },

        /**
        Assigns attachment content to the correct attachment to create a StatementsResult object that is sent
        to the callback of queryStatements()

        @method _assignAttachmentContent
        @private
        @param {Array} [stmts] Array of TinCan.Statement JSON objects
        @param {Object} [attachmentMap] Map of the content to place into its attachment
        @return {Array} Array of TinCan.Statement JSON objects with correctly assigned attachment content
        */
        _assignAttachmentContent: function (stmts, attachmentMap) {
            var i,
                j;

            for (i = 0; i &lt; stmts.length; i += 1) {
                if (stmts[i].hasOwnProperty(&quot;attachments&quot;) &amp;&amp; stmts[i].attachments !== null) {
                    for (j = 0; j &lt; stmts[i].attachments.length; j += 1) {
                        if (attachmentMap.hasOwnProperty(stmts[i].attachments[j].sha2)) {
                            stmts[i].attachments[j].content = attachmentMap[stmts[i].attachments[j].sha2];
                        }
                    }
                }
            }
        },

        /**
        Parses the different sections of a multipart/mixed response

        @method _parseMultipart
        @private
        @param {String} [boundary] Boundary used to mark off the sections of the response
        @param {ArrayBuffer} [response] Body of the response
        @return {Array} Array of objects containing the parsed headers and body of each part
        */
        _parseMultipart: function (boundary, response) {
            /* global Uint8Array */
            var __boundary = &quot;--&quot; + boundary,
                byteArray,
                bodyEncodedInString,
                fullBodyEnd,
                sliceStart,
                sliceEnd,
                headerStart,
                headerEnd,
                bodyStart,
                bodyEnd,
                headers,
                body,
                parts = [],
                CRLF = 2;

            //
            // treating the reponse as a stream of bytes and assuming that headers
            // and related mime boundaries are all US-ASCII (which is a safe assumption)
            // allows us to treat the whole response as a string when looking for offsets
            // but then slice on the raw array buffer
            //
            byteArray = new Uint8Array(response);
            bodyEncodedInString = this.__uint8ToString(byteArray);

            fullBodyEnd = bodyEncodedInString.indexOf(__boundary + &quot;--&quot;);

            sliceStart = bodyEncodedInString.indexOf(__boundary);
            while (sliceStart !== -1) {
                sliceEnd = bodyEncodedInString.indexOf(__boundary, sliceStart + __boundary.length);

                headerStart = sliceStart + __boundary.length + CRLF;
                headerEnd = bodyEncodedInString.indexOf(&quot;\r\n\r\n&quot;, sliceStart);
                bodyStart = headerEnd + CRLF + CRLF;
                bodyEnd = sliceEnd - 2;

                headers = this._parseHeaders(
                    this.__uint8ToString(
                        new Uint8Array( response.slice(headerStart, headerEnd) )
                    )
                );
                body = response.slice(bodyStart, bodyEnd);

                //
                // we know the first slice is the statement, and we know it is a string in UTF-8 (spec requirement)
                //
                if (parts.length === 0) {
                    body = TinCan.Utils.stringFromArrayBuffer(body);
                }

                parts.push(
                    {
                        headers: headers,
                        body: body
                    }
                );

                if (sliceEnd === fullBodyEnd) {
                    sliceStart = -1;
                }
                else {
                    sliceStart = sliceEnd;
                }
            }

            return parts;
        },

        //
        // implemented as a function to avoid &#x27;RangeError: Maximum call stack size exceeded&#x27;
        // when calling .fromCharCode on the full byteArray which results in a too long
        // argument list for large arrays
        //
        __uint8ToString: function (byteArray) {
            var result = &quot;&quot;,
                len = byteArray.byteLength,
                i;

            for (i = 0; i &lt; len; i += 1) {
                result += String.fromCharCode(byteArray[i]);
            }
            return result;
        },

        /**
        Parses the headers of a multipart/mixed response section

        @method _parseHeaders
        @private
        @param {String} [rawHeaders] String containing all the headers
        @return {Object} Map of the headers
        */
        _parseHeaders: function (rawHeaders) {
            var headers = {},
                headerList,
                key,
                h,
                i;

            headerList = rawHeaders.split(&quot;\n&quot;);
            for (i = 0; i &lt; headerList.length; i += 1) {
                h = headerList[i].split(&quot;:&quot;, 2);

                if (h[1] !== null) {
                    headers[h[0]] = h[1].replace(/^\s+|\s+$/g, &quot;&quot;);

                    key = h[0];
                }
                else {
                    if (h[0].substring(0, 1) === &quot;\t&quot;) {
                        headers[h[0]] = h[1].replace(/^\s+|\s+$/g, &quot;&quot;);
                    }
                }
            }

            return headers;
        },

        /**
        Fetch more statements from a previous query, when used from a browser sends to the endpoint using the
        RESTful interface.  Use a callback to make the call asynchronous.

        @method moreStatements
        @param {Object} [cfg] Configuration used to query
            @param {String} [cfg.url] More URL
            @param {Function} [cfg.callback] Callback to execute on completion
                @param {String|null} cfg.callback.err Error status or null if succcess
                @param {TinCan.StatementsResult|XHR} cfg.callback.response Receives a StatementsResult argument
        @return {Object} Request result
        */
        moreStatements: function (cfg) {
            this.log(&quot;moreStatements: &quot; + cfg.url);
            var requestCfg,
                requestResult,
                callbackWrapper,
                parsedURL,
                serverRoot;

            cfg = cfg || {};

            // to support our interface (to support IE) we need to break apart
            // the more URL query params so that the request can be made properly later
            parsedURL = TinCan.Utils.parseURL(cfg.url, { allowRelative: true });

            // Respect a more URL that is relative to either the server root
            // or endpoint (though only the former is allowed in the spec)
            serverRoot = TinCan.Utils.getServerRoot(this.endpoint);
            if (parsedURL.path.indexOf(&quot;/statements&quot;) === 0){
                parsedURL.path = this.endpoint.replace(serverRoot, &quot;&quot;) + parsedURL.path;
                this.log(&quot;converting non-standard more URL to &quot; + parsedURL.path);
            }

            // The more relative URL might not start with a slash, add it if not
            if (parsedURL.path.indexOf(&quot;/&quot;) !== 0) {
                parsedURL.path = &quot;/&quot; + parsedURL.path;
            }

            requestCfg = {
                method: &quot;GET&quot;,
                // For arbitrary more URLs to work, we need to make the URL absolute here
                url: serverRoot + parsedURL.path,
                params: parsedURL.params
            };
            if (typeof cfg.callback !== &quot;undefined&quot;) {
                callbackWrapper = function (err, xhr) {
                    var result = xhr;

                    if (err === null) {
                        result = TinCan.StatementsResult.fromJSON(xhr.responseText);
                    }

                    cfg.callback(err, result);
                };
                requestCfg.callback = callbackWrapper;
            }

            requestResult = this.sendRequest(requestCfg);
            requestResult.config = requestCfg;

            if (! callbackWrapper) {
                requestResult.statementsResult = null;
                if (requestResult.err === null) {
                    requestResult.statementsResult = TinCan.StatementsResult.fromJSON(requestResult.xhr.responseText);
                }
            }

            return requestResult;
        },

        /**
        Retrieve a state value, when used from a browser sends to the endpoint using the RESTful interface.

        @method retrieveState
        @param {String} key Key of state to retrieve
        @param {Object} cfg Configuration options
            @param {TinCan.Activity} cfg.activity Activity in document identifier
            @param {TinCan.Agent} cfg.agent Agent in document identifier
            @param {String} [cfg.registration] Registration
            @param {Function} [cfg.callback] Callback to execute on completion
                @param {Object|Null} cfg.callback.error
                @param {TinCan.State|null} cfg.callback.result null if state is 404
            @param {Object} [cfg.requestHeaders] Object containing additional headers to add to request
        @return {TinCan.State|Object} TinCan.State retrieved when synchronous, or result from sendRequest
        */
        retrieveState: function (key, cfg) {
            this.log(&quot;retrieveState&quot;);
            var requestParams = {},
                requestCfg = {},
                requestResult,
                callbackWrapper,
                requestHeaders,
                self = this;

            requestHeaders = cfg.requestHeaders || {};

            requestParams = {
                stateId: key,
                activityId: cfg.activity.id
            };
            if (this.version === &quot;0.9&quot;) {
                requestParams.actor = JSON.stringify(cfg.agent.asVersion(this.version));
            }
            else {
                requestParams.agent = JSON.stringify(cfg.agent.asVersion(this.version));
            }
            if ((typeof cfg.registration !== &quot;undefined&quot;) &amp;&amp; (cfg.registration !== null)) {
                if (this.version === &quot;0.9&quot;) {
                    requestParams.registrationId = cfg.registration;
                }
                else {
                    requestParams.registration = cfg.registration;
                }
            }

            requestCfg = {
                url: &quot;activities/state&quot;,
                method: &quot;GET&quot;,
                params: requestParams,
                ignore404: true,
                headers: requestHeaders
            };

            if (typeof cfg.callback !== &quot;undefined&quot;) {
                callbackWrapper = function (err, xhr) {
                    var result = xhr;

                    if (err === null) {
                        if (xhr.status === 404) {
                            result = null;
                        }
                        else {
                            result = new TinCan.State(
                                {
                                    id: key,
                                    contents: xhr.responseText
                                }
                            );
                            if (typeof xhr.getResponseHeader !== &quot;undefined&quot; &amp;&amp; xhr.getResponseHeader(&quot;ETag&quot;) !== null &amp;&amp; xhr.getResponseHeader(&quot;ETag&quot;) !== &quot;&quot;) {
                                result.etag = xhr.getResponseHeader(&quot;ETag&quot;);
                            }
                            else {
                                //
                                // either XHR didn&#x27;t have getResponseHeader (probably cause it is an IE
                                // XDomainRequest object which doesn&#x27;t) or not populated by LRS so create
                                // the hash ourselves
                                //
                                // the LRS is responsible for quoting the Etag value so we need to mimic
                                // that behavior here as well
                                //
                                result.etag = &quot;\&quot;&quot; + TinCan.Utils.getSHA1String(xhr.responseText) + &quot;\&quot;&quot;;
                            }

                            if (typeof xhr.contentType !== &quot;undefined&quot;) {
                                // most likely an XDomainRequest which has .contentType,
                                // for the ones that it supports
                                result.contentType = xhr.contentType;
                            }
                            else if (typeof xhr.getResponseHeader !== &quot;undefined&quot; &amp;&amp; xhr.getResponseHeader(&quot;Content-Type&quot;) !== null &amp;&amp; xhr.getResponseHeader(&quot;Content-Type&quot;) !== &quot;&quot;) {
                                result.contentType = xhr.getResponseHeader(&quot;Content-Type&quot;);
                            }

                            if (TinCan.Utils.isApplicationJSON(result.contentType)) {
                                try {
                                    result.contents = JSON.parse(result.contents);
                                } catch (ex) {
                                    self.log(&quot;retrieveState - failed to deserialize JSON: &quot; + ex);
                                }
                            }
                        }
                    }

                    cfg.callback(err, result);
                };
                requestCfg.callback = callbackWrapper;
            }

            requestResult = this.sendRequest(requestCfg);
            if (! callbackWrapper) {
                requestResult.state = null;
                if (requestResult.err === null &amp;&amp; requestResult.xhr.status !== 404) {
                    requestResult.state = new TinCan.State(
                        {
                            id: key,
                            contents: requestResult.xhr.responseText
                        }
                    );
                    if (typeof requestResult.xhr.getResponseHeader !== &quot;undefined&quot; &amp;&amp; requestResult.xhr.getResponseHeader(&quot;ETag&quot;) !== null &amp;&amp; requestResult.xhr.getResponseHeader(&quot;ETag&quot;) !== &quot;&quot;) {
                        requestResult.state.etag = requestResult.xhr.getResponseHeader(&quot;ETag&quot;);
                    }
                    else {
                        //
                        // either XHR didn&#x27;t have getResponseHeader (probably cause it is an IE
                        // XDomainRequest object which doesn&#x27;t) or not populated by LRS so create
                        // the hash ourselves
                        //
                        // the LRS is responsible for quoting the Etag value so we need to mimic
                        // that behavior here as well
                        //
                        requestResult.state.etag = &quot;\&quot;&quot; + TinCan.Utils.getSHA1String(requestResult.xhr.responseText) + &quot;\&quot;&quot;;
                    }
                    if (typeof requestResult.xhr.contentType !== &quot;undefined&quot;) {
                        // most likely an XDomainRequest which has .contentType
                        // for the ones that it supports
                        requestResult.state.contentType = requestResult.xhr.contentType;
                    }
                    else if (typeof requestResult.xhr.getResponseHeader !== &quot;undefined&quot; &amp;&amp; requestResult.xhr.getResponseHeader(&quot;Content-Type&quot;) !== null &amp;&amp; requestResult.xhr.getResponseHeader(&quot;Content-Type&quot;) !== &quot;&quot;) {
                        requestResult.state.contentType = requestResult.xhr.getResponseHeader(&quot;Content-Type&quot;);
                    }
                    if (TinCan.Utils.isApplicationJSON(requestResult.state.contentType)) {
                        try {
                            requestResult.state.contents = JSON.parse(requestResult.state.contents);
                        } catch (ex) {
                            this.log(&quot;retrieveState - failed to deserialize JSON: &quot; + ex);
                        }
                    }
                }
            }

            return requestResult;
        },

        /**
        Retrieve the list of IDs for a state, when used from a browser sends to the endpoint using the RESTful interface.

        @method retrieveStateIds
        @param {Object} cfg Configuration options
            @param {TinCan.Activity} cfg.activity Activity in document identifier
            @param {TinCan.Agent} cfg.agent Agent in document identifier
            @param {String} [cfg.registration] Registration
            @param {Function} [cfg.callback] Callback to execute on completion
            @param {String} [cfg.since] Match activity profiles saved since given timestamp
            @param {Object} [cfg.requestHeaders] Optional object containing additional headers to add to request
        @return {Object} requestResult Request result
        */
        retrieveStateIds: function (cfg) {
            this.log(&quot;retrieveStateIds&quot;);
            var requestParams = {},
                requestCfg,
                requestHeaders,
                requestResult,
                callbackWrapper;

            cfg = cfg || {};
            requestHeaders = cfg.requestHeaders || {};

            requestParams.activityId = cfg.activity.id;
            if (this.version === &quot;0.9&quot;) {
                requestParams.actor = JSON.stringify(cfg.agent.asVersion(this.version));
            }
            else {
                requestParams.agent = JSON.stringify(cfg.agent.asVersion(this.version));
            }
            if ((typeof cfg.registration !== &quot;undefined&quot;) &amp;&amp; (cfg.registration !== null)) {
                if (this.version === &quot;0.9&quot;) {
                    requestParams.registrationId = cfg.registration;
                }
                else {
                    requestParams.registration = cfg.registration;
                }
            }

            requestCfg = {
                url: &quot;activities/state&quot;,
                method: &quot;GET&quot;,
                params: requestParams,
                headers: requestHeaders,
                ignore404: true
            };
            if (typeof cfg.callback !== &quot;undefined&quot;) {
                callbackWrapper = function (err, xhr) {
                    var result = xhr;

                    if (err !== null) {
                        cfg.callback(err, result);
                        return;
                    }

                    if (xhr.status === 404) {
                        result = [];
                    }
                    else {
                        try {
                            result = JSON.parse(xhr.responseText);
                        }
                        catch (ex) {
                            err = &quot;Response JSON parse error: &quot; + ex;
                        }
                    }

                    cfg.callback(err, result);
                };
                requestCfg.callback = callbackWrapper;
            }
            if (typeof cfg.since !== &quot;undefined&quot;) {
                requestCfg.params.since = cfg.since;
            }

            requestResult = this.sendRequest(requestCfg);
            if (! callbackWrapper) {
                requestResult.profileIds = null;
                if (requestResult.err !== null) {
                    return requestResult;
                }

                if (requestResult.xhr.status === 404) {
                    requestResult.profileIds = [];
                }
                else {
                    try {
                        requestResult.profileIds = JSON.parse(requestResult.xhr.responseText);
                    }
                    catch (ex) {
                        requestResult.err = &quot;retrieveStateIds - JSON parse error: &quot; + ex;
                    }
                }
            }
            return requestResult;
        },

        /**
        Save a state value, when used from a browser sends to the endpoint using the RESTful interface.

        @method saveState
        @param {String} key Key of state to save
        @param val Value to be stored
        @param {Object} cfg Configuration options
            @param {TinCan.Activity} cfg.activity Activity in document identifier
            @param {TinCan.Agent} cfg.agent Agent in document identifier
            @param {String} [cfg.registration] Registration
            @param {String} [cfg.lastSHA1] SHA1 of the previously seen existing state
            @param {String} [cfg.contentType] Content-Type to specify in headers (defaults to &#x27;application/octet-stream&#x27;)
            @param {String} [cfg.method] Method to use. Default: PUT
            @param {Function} [cfg.callback] Callback to execute on completion
            @param {Object} [cfg.requestHeaders] Optional object containing additional headers to add to request
        */
        saveState: function (key, val, cfg) {
            this.log(&quot;saveState&quot;);
            var requestParams,
                requestCfg,
                requestHeaders;

            requestHeaders = cfg.requestHeaders || {};

            if (typeof cfg.contentType === &quot;undefined&quot;) {
                cfg.contentType = &quot;application/octet-stream&quot;;
            }
            requestHeaders[&quot;Content-Type&quot;] = cfg.contentType;

            if (typeof val === &quot;object&quot; &amp;&amp; TinCan.Utils.isApplicationJSON(cfg.contentType)) {
                val = JSON.stringify(val);
            }

            if (typeof cfg.method === &quot;undefined&quot; || cfg.method !== &quot;POST&quot;) {
                cfg.method = &quot;PUT&quot;;
            }

            requestParams = {
                stateId: key,
                activityId: cfg.activity.id
            };
            if (this.version === &quot;0.9&quot;) {
                requestParams.actor = JSON.stringify(cfg.agent.asVersion(this.version));
            }
            else {
                requestParams.agent = JSON.stringify(cfg.agent.asVersion(this.version));
            }
            if ((typeof cfg.registration !== &quot;undefined&quot;) &amp;&amp; (cfg.registration !== null)) {
                if (this.version === &quot;0.9&quot;) {
                    requestParams.registrationId = cfg.registration;
                }
                else {
                    requestParams.registration = cfg.registration;
                }
            }

            requestCfg = {
                url: &quot;activities/state&quot;,
                method: cfg.method,
                params: requestParams,
                data: val,
                headers: requestHeaders
            };

            if (typeof cfg.callback !== &quot;undefined&quot;) {
                requestCfg.callback = cfg.callback;
            }
            if (typeof cfg.lastSHA1 !== &quot;undefined&quot; &amp;&amp; cfg.lastSHA1 !== null) {
                requestCfg.headers[&quot;If-Match&quot;] = cfg.lastSHA1;
            }

            return this.sendRequest(requestCfg);
        },

        /**
        Drop a state value or all of the state, when used from a browser sends to the endpoint using the RESTful interface.

        @method dropState
        @param {String|null} key Key of state to delete, or null for all
        @param {Object} cfg Configuration options
            @param {TinCan.Activity} cfg.activity Activity in document identifier
            @param {TinCan.Agent} cfg.agent Agent in document identifier
            @param {String} [cfg.registration] Registration
            @param {Function} [cfg.callback] Callback to execute on completion
            @param {Object} [cfg.requestHeaders] Optional object containing additional headers to add to request
        */
        dropState: function (key, cfg) {
            this.log(&quot;dropState&quot;);
            var requestParams,
                requestCfg,
                requestHeaders;

            requestHeaders = cfg.requestHeaders || {};

            requestParams = {
                activityId: cfg.activity.id
            };
            if (this.version === &quot;0.9&quot;) {
                requestParams.actor = JSON.stringify(cfg.agent.asVersion(this.version));
            }
            else {
                requestParams.agent = JSON.stringify(cfg.agent.asVersion(this.version));
            }
            if (key !== null) {
                requestParams.stateId = key;
            }
            if ((typeof cfg.registration !== &quot;undefined&quot;) &amp;&amp; (cfg.registration !== null)) {
                if (this.version === &quot;0.9&quot;) {
                    requestParams.registrationId = cfg.registration;
                }
                else {
                    requestParams.registration = cfg.registration;
                }
            }

            requestCfg = {
                url: &quot;activities/state&quot;,
                method: &quot;DELETE&quot;,
                params: requestParams,
                headers: requestHeaders
            };

            if (typeof cfg.callback !== &quot;undefined&quot;) {
                requestCfg.callback = cfg.callback;
            }

            return this.sendRequest(requestCfg);
        },

        /**
        Retrieve an activity, when used from a browser sends to the endpoint using the RESTful interface.

        @method retrieveActivity
        @param {String} activityId id of the Activity to retrieve
        @param {Object} cfg Configuration options
            @param {Function} [cfg.callback] Callback to execute on completion
            @param {Object} [cfg.requestHeaders] Optional object containing additional headers to add to request
        @return {Object} Value retrieved
        */
        retrieveActivity: function (activityId, cfg) {
            this.log(&quot;retrieveActivity&quot;);
            var requestCfg = {},
                requestResult,
                callbackWrapper,
                requestHeaders;

            requestHeaders = cfg.requestHeaders || {};

            requestCfg = {
                url: &quot;activities&quot;,
                method: &quot;GET&quot;,
                params: {
                    activityId: activityId
                },
                ignore404: true,
                headers: requestHeaders
            };

            if (typeof cfg.callback !== &quot;undefined&quot;) {
                callbackWrapper = function (err, xhr) {
                    var result = xhr;

                    if (err === null) {
                        //
                        // a 404 really shouldn&#x27;t happen because the LRS can dynamically
                        // build the response based on what has been passed to it, but
                        // don&#x27;t have the client fail in the condition that it does, because
                        // we can do the same thing
                        //
                        if (xhr.status === 404) {
                            result = new TinCan.Activity(
                                {
                                    id: activityId
                                }
                            );
                        }
                        else {
                            result = TinCan.Activity.fromJSON(xhr.responseText);
                        }
                    }

                    cfg.callback(err, result);
                };
                requestCfg.callback = callbackWrapper;
            }

            requestResult = this.sendRequest(requestCfg);
            if (! callbackWrapper) {
                requestResult.activity = null;
                if (requestResult.err === null) {
                    if (requestResult.xhr.status === 404) {
                        requestResult.activity = new TinCan.Activity(
                            {
                                id: activityId
                            }
                        );
                    }
                    else {
                        requestResult.activity = TinCan.Activity.fromJSON(requestResult.xhr.responseText);
                    }
                }
            }

            return requestResult;
        },

        /**
        Retrieve an activity profile value, when used from a browser sends to the endpoint using the RESTful interface.

        @method retrieveActivityProfile
        @param {String} key Key of activity profile to retrieve
        @param {Object} cfg Configuration options
            @param {TinCan.Activity} cfg.activity Activity in document identifier
            @param {Function} [cfg.callback] Callback to execute on completion
            @param {Object} [cfg.requestHeaders] Optional object containing additional headers to add to request
        @return {Object} Value retrieved
        */
        retrieveActivityProfile: function (key, cfg) {
            this.log(&quot;retrieveActivityProfile&quot;);
            var requestCfg = {},
                requestResult,
                callbackWrapper,
                requestHeaders,
                self = this;

            requestHeaders = cfg.requestHeaders || {};

            requestCfg = {
                url: &quot;activities/profile&quot;,
                method: &quot;GET&quot;,
                params: {
                    profileId: key,
                    activityId: cfg.activity.id
                },
                ignore404: true,
                headers: requestHeaders
            };

            if (typeof cfg.callback !== &quot;undefined&quot;) {
                callbackWrapper = function (err, xhr) {
                    var result = xhr;

                    if (err === null) {
                        if (xhr.status === 404) {
                            result = null;
                        }
                        else {
                            result = new TinCan.ActivityProfile(
                                {
                                    id: key,
                                    activity: cfg.activity,
                                    contents: xhr.responseText
                                }
                            );
                            if (typeof xhr.getResponseHeader !== &quot;undefined&quot; &amp;&amp; xhr.getResponseHeader(&quot;ETag&quot;) !== null &amp;&amp; xhr.getResponseHeader(&quot;ETag&quot;) !== &quot;&quot;) {
                                result.etag = xhr.getResponseHeader(&quot;ETag&quot;);
                            }
                            else {
                                //
                                // either XHR didn&#x27;t have getResponseHeader (probably cause it is an IE
                                // XDomainRequest object which doesn&#x27;t) or not populated by LRS so create
                                // the hash ourselves
                                //
                                // the LRS is responsible for quoting the Etag value so we need to mimic
                                // that behavior here as well
                                //
                                result.etag = &quot;\&quot;&quot; + TinCan.Utils.getSHA1String(xhr.responseText) + &quot;\&quot;&quot;;
                            }
                            if (typeof xhr.contentType !== &quot;undefined&quot;) {
                                // most likely an XDomainRequest which has .contentType
                                // for the ones that it supports
                                result.contentType = xhr.contentType;
                            }
                            else if (typeof xhr.getResponseHeader !== &quot;undefined&quot; &amp;&amp; xhr.getResponseHeader(&quot;Content-Type&quot;) !== null &amp;&amp; xhr.getResponseHeader(&quot;Content-Type&quot;) !== &quot;&quot;) {
                                result.contentType = xhr.getResponseHeader(&quot;Content-Type&quot;);
                            }
                            if (TinCan.Utils.isApplicationJSON(result.contentType)) {
                                try {
                                    result.contents = JSON.parse(result.contents);
                                } catch (ex) {
                                    self.log(&quot;retrieveActivityProfile - failed to deserialize JSON: &quot; + ex);
                                }
                            }
                        }
                    }

                    cfg.callback(err, result);
                };
                requestCfg.callback = callbackWrapper;
            }

            requestResult = this.sendRequest(requestCfg);
            if (! callbackWrapper) {
                requestResult.profile = null;
                if (requestResult.err === null &amp;&amp; requestResult.xhr.status !== 404) {
                    requestResult.profile = new TinCan.ActivityProfile(
                        {
                            id: key,
                            activity: cfg.activity,
                            contents: requestResult.xhr.responseText
                        }
                    );
                    if (typeof requestResult.xhr.getResponseHeader !== &quot;undefined&quot; &amp;&amp; requestResult.xhr.getResponseHeader(&quot;ETag&quot;) !== null &amp;&amp; requestResult.xhr.getResponseHeader(&quot;ETag&quot;) !== &quot;&quot;) {
                        requestResult.profile.etag = requestResult.xhr.getResponseHeader(&quot;ETag&quot;);
                    }
                    else {
                        //
                        // either XHR didn&#x27;t have getResponseHeader (probably cause it is an IE
                        // XDomainRequest object which doesn&#x27;t) or not populated by LRS so create
                        // the hash ourselves
                        //
                        // the LRS is responsible for quoting the Etag value so we need to mimic
                        // that behavior here as well
                        //
                        requestResult.profile.etag = &quot;\&quot;&quot; + TinCan.Utils.getSHA1String(requestResult.xhr.responseText) + &quot;\&quot;&quot;;
                    }
                    if (typeof requestResult.xhr.contentType !== &quot;undefined&quot;) {
                        // most likely an XDomainRequest which has .contentType
                        // for the ones that it supports
                        requestResult.profile.contentType = requestResult.xhr.contentType;
                    }
                    else if (typeof requestResult.xhr.getResponseHeader !== &quot;undefined&quot; &amp;&amp; requestResult.xhr.getResponseHeader(&quot;Content-Type&quot;) !== null &amp;&amp; requestResult.xhr.getResponseHeader(&quot;Content-Type&quot;) !== &quot;&quot;) {
                        requestResult.profile.contentType = requestResult.xhr.getResponseHeader(&quot;Content-Type&quot;);
                    }
                    if (TinCan.Utils.isApplicationJSON(requestResult.profile.contentType)) {
                        try {
                            requestResult.profile.contents = JSON.parse(requestResult.profile.contents);
                        } catch (ex) {
                            this.log(&quot;retrieveActivityProfile - failed to deserialize JSON: &quot; + ex);
                        }
                    }
                }
            }

            return requestResult;
        },

        /**
        Retrieve the list of IDs for an activity profile, when used from a browser sends to the endpoint using the RESTful interface.

        @method retrieveActivityProfileIds
        @param {Object} cfg Configuration options
            @param {TinCan.Activity} cfg.activity Activity in document identifier
            @param {Function} [cfg.callback] Callback to execute on completion
            @param {String} [cfg.since] Match activity profiles saved since given timestamp
            @param {Object} [cfg.requestHeaders] Optional object containing additional headers to add to request
        @return {Array} List of ids for this Activity profile
        */
        retrieveActivityProfileIds: function (cfg) {
            this.log(&quot;retrieveActivityProfileIds&quot;);
            var requestCfg,
                requestHeaders,
                requestResult,
                callbackWrapper;

            cfg = cfg || {};
            requestHeaders = cfg.requestHeaders || {};

            requestCfg = {
                url: &quot;activities/profile&quot;,
                method: &quot;GET&quot;,
                params: {
                    activityId: cfg.activity.id
                },
                headers: requestHeaders,
                ignore404: true
            };
            if (typeof cfg.callback !== &quot;undefined&quot;) {
                callbackWrapper = function (err, xhr) {
                    var result = xhr;

                    if (err !== null) {
                        cfg.callback(err, result);
                        return;
                    }

                    if (xhr.status === 404) {
                        result = [];
                    }
                    else {
                        try {
                            result = JSON.parse(xhr.responseText);
                        }
                        catch (ex) {
                            err = &quot;Response JSON parse error: &quot; + ex;
                        }
                    }

                    cfg.callback(err, result);
                };
                requestCfg.callback = callbackWrapper;
            }
            if (typeof cfg.since !== &quot;undefined&quot;) {
                requestCfg.params.since = cfg.since;
            }

            requestResult = this.sendRequest(requestCfg);
            if (! callbackWrapper) {
                requestResult.profileIds = null;
                if (requestResult.err !== null) {
                    return requestResult;
                }

                if (requestResult.xhr.status === 404) {
                    requestResult.profileIds = [];
                }
                else {
                    try {
                        requestResult.profileIds = JSON.parse(requestResult.xhr.responseText);
                    }
                    catch (ex) {
                        requestResult.err = &quot;retrieveActivityProfileIds - JSON parse error: &quot; + ex;
                    }
                }
            }
            return requestResult;
        },

        /**
        Save an activity profile value, when used from a browser sends to the endpoint using the RESTful interface.

        @method saveActivityProfile
        @param {String} key Key of activity profile to retrieve
        @param val Value to be stored
        @param {Object} cfg Configuration options
            @param {TinCan.Activity} cfg.activity Activity in document identifier
            @param {String} [cfg.lastSHA1] SHA1 of the previously seen existing profile
            @param {String} [cfg.contentType] Content-Type to specify in headers (defaults to &#x27;application/octet-stream&#x27;)
            @param {String} [cfg.method] Method to use. Default: PUT
            @param {Function} [cfg.callback] Callback to execute on completion
            @param {Object} [cfg.requestHeaders] Optional object containing additional headers to add to request
        */
        saveActivityProfile: function (key, val, cfg) {
            this.log(&quot;saveActivityProfile&quot;);
            var requestCfg,
                requestHeaders;

            requestHeaders = cfg.requestHeaders || {};

            if (typeof cfg.contentType === &quot;undefined&quot;) {
                cfg.contentType = &quot;application/octet-stream&quot;;
            }
            requestHeaders[&quot;Content-Type&quot;] = cfg.contentType;

            if (typeof cfg.method === &quot;undefined&quot; || cfg.method !== &quot;POST&quot;) {
                cfg.method = &quot;PUT&quot;;
            }

            if (typeof val === &quot;object&quot; &amp;&amp; TinCan.Utils.isApplicationJSON(cfg.contentType)) {
                val = JSON.stringify(val);
            }

            requestCfg = {
                url: &quot;activities/profile&quot;,
                method: cfg.method,
                params: {
                    profileId: key,
                    activityId: cfg.activity.id
                },
                data: val,
                headers: requestHeaders
            };

            if (typeof cfg.callback !== &quot;undefined&quot;) {
                requestCfg.callback = cfg.callback;
            }
            if (typeof cfg.lastSHA1 !== &quot;undefined&quot; &amp;&amp; cfg.lastSHA1 !== null) {
                requestCfg.headers[&quot;If-Match&quot;] = cfg.lastSHA1;
            }
            else {
                requestCfg.headers[&quot;If-None-Match&quot;] = &quot;*&quot;;
            }

            return this.sendRequest(requestCfg);
        },

        /**
        Drop an activity profile value, when used from a browser sends to the endpoint using the RESTful interface. Full activity profile
        delete is not supported by the spec.

        @method dropActivityProfile
        @param {String|null} key Key of activity profile to delete
        @param {Object} cfg Configuration options
            @param {TinCan.Activity} cfg.activity Activity in document identifier
            @param {Function} [cfg.callback] Callback to execute on completion
            @param {Object} [cfg.requestHeaders] Optional object containing additional headers to add to request
        */
        dropActivityProfile: function (key, cfg) {
            this.log(&quot;dropActivityProfile&quot;);
            var requestParams,
                requestCfg,
                requestHeaders;

            requestHeaders = cfg.requestHeaders || {};

            requestParams = {
                profileId: key,
                activityId: cfg.activity.id
            };

            requestCfg = {
                url: &quot;activities/profile&quot;,
                method: &quot;DELETE&quot;,
                params: requestParams,
                headers: requestHeaders
            };

            if (typeof cfg.callback !== &quot;undefined&quot;) {
                requestCfg.callback = cfg.callback;
            }

            return this.sendRequest(requestCfg);
        },

        /**
        Retrieve an agent profile value, when used from a browser sends to the endpoint using the RESTful interface.

        @method retrieveAgentProfile
        @param {String} key Key of agent profile to retrieve
        @param {Object} cfg Configuration options
            @param {TinCan.Agent} cfg.agent Agent in document identifier
            @param {Function} [cfg.callback] Callback to execute on completion
            @param {Object} [cfg.requestHeaders] Optional object containing additional headers to add to request
        @return {Object} Value retrieved
        */
        retrieveAgentProfile: function (key, cfg) {
            this.log(&quot;retrieveAgentProfile&quot;);
            var requestCfg = {},
                requestResult,
                callbackWrapper,
                requestHeaders,
                self = this;

            requestHeaders = cfg.requestHeaders || {};

            requestCfg = {
                method: &quot;GET&quot;,
                params: {
                    profileId: key
                },
                ignore404: true,
                headers: requestHeaders
            };

            if (this.version === &quot;0.9&quot;) {
                requestCfg.url = &quot;actors/profile&quot;;
                requestCfg.params.actor = JSON.stringify(cfg.agent.asVersion(this.version));
            }
            else {
                requestCfg.url = &quot;agents/profile&quot;;
                requestCfg.params.agent = JSON.stringify(cfg.agent.asVersion(this.version));
            }
            if (typeof cfg.callback !== &quot;undefined&quot;) {
                callbackWrapper = function (err, xhr) {
                    var result = xhr;

                    if (err === null) {
                        if (xhr.status === 404) {
                            result = null;
                        }
                        else {
                            result = new TinCan.AgentProfile(
                                {
                                    id: key,
                                    agent: cfg.agent,
                                    contents: xhr.responseText
                                }
                            );
                            if (typeof xhr.getResponseHeader !== &quot;undefined&quot; &amp;&amp; xhr.getResponseHeader(&quot;ETag&quot;) !== null &amp;&amp; xhr.getResponseHeader(&quot;ETag&quot;) !== &quot;&quot;) {
                                result.etag = xhr.getResponseHeader(&quot;ETag&quot;);
                            }
                            else {
                                //
                                // either XHR didn&#x27;t have getResponseHeader (probably cause it is an IE
                                // XDomainRequest object which doesn&#x27;t) or not populated by LRS so create
                                // the hash ourselves
                                //
                                // the LRS is responsible for quoting the Etag value so we need to mimic
                                // that behavior here as well
                                //
                                result.etag = &quot;\&quot;&quot; + TinCan.Utils.getSHA1String(xhr.responseText) + &quot;\&quot;&quot;;
                            }
                            if (typeof xhr.contentType !== &quot;undefined&quot;) {
                                // most likely an XDomainRequest which has .contentType
                                // for the ones that it supports
                                result.contentType = xhr.contentType;
                            }
                            else if (typeof xhr.getResponseHeader !== &quot;undefined&quot; &amp;&amp; xhr.getResponseHeader(&quot;Content-Type&quot;) !== null &amp;&amp; xhr.getResponseHeader(&quot;Content-Type&quot;) !== &quot;&quot;) {
                                result.contentType = xhr.getResponseHeader(&quot;Content-Type&quot;);
                            }
                            if (TinCan.Utils.isApplicationJSON(result.contentType)) {
                                try {
                                    result.contents = JSON.parse(result.contents);
                                } catch (ex) {
                                    self.log(&quot;retrieveAgentProfile - failed to deserialize JSON: &quot; + ex);
                                }
                            }
                        }
                    }

                    cfg.callback(err, result);
                };
                requestCfg.callback = callbackWrapper;
            }

            requestResult = this.sendRequest(requestCfg);
            if (! callbackWrapper) {
                requestResult.profile = null;
                if (requestResult.err === null &amp;&amp; requestResult.xhr.status !== 404) {
                    requestResult.profile = new TinCan.AgentProfile(
                        {
                            id: key,
                            agent: cfg.agent,
                            contents: requestResult.xhr.responseText
                        }
                    );
                    if (typeof requestResult.xhr.getResponseHeader !== &quot;undefined&quot; &amp;&amp; requestResult.xhr.getResponseHeader(&quot;ETag&quot;) !== null &amp;&amp; requestResult.xhr.getResponseHeader(&quot;ETag&quot;) !== &quot;&quot;) {
                        requestResult.profile.etag = requestResult.xhr.getResponseHeader(&quot;ETag&quot;);
                    }
                    else {
                        //
                        // either XHR didn&#x27;t have getResponseHeader (probably cause it is an IE
                        // XDomainRequest object which doesn&#x27;t) or not populated by LRS so create
                        // the hash ourselves
                        //
                        // the LRS is responsible for quoting the Etag value so we need to mimic
                        // that behavior here as well
                        //
                        requestResult.profile.etag = &quot;\&quot;&quot; + TinCan.Utils.getSHA1String(requestResult.xhr.responseText) + &quot;\&quot;&quot;;
                    }
                    if (typeof requestResult.xhr.contentType !== &quot;undefined&quot;) {
                        // most likely an XDomainRequest which has .contentType
                        // for the ones that it supports
                        requestResult.profile.contentType = requestResult.xhr.contentType;
                    }
                    else if (typeof requestResult.xhr.getResponseHeader !== &quot;undefined&quot; &amp;&amp; requestResult.xhr.getResponseHeader(&quot;Content-Type&quot;) !== null &amp;&amp; requestResult.xhr.getResponseHeader(&quot;Content-Type&quot;) !== &quot;&quot;) {
                        requestResult.profile.contentType = requestResult.xhr.getResponseHeader(&quot;Content-Type&quot;);
                    }
                    if (TinCan.Utils.isApplicationJSON(requestResult.profile.contentType)) {
                        try {
                            requestResult.profile.contents = JSON.parse(requestResult.profile.contents);
                        } catch (ex) {
                            this.log(&quot;retrieveAgentProfile - failed to deserialize JSON: &quot; + ex);
                        }
                    }
                }
            }

            return requestResult;
        },

        /**
        Retrieve the list of profileIds for an agent profile, when used from a browser sends to the endpoint using the RESTful interface.

        @method retrieveAgentProfileIds
        @param {Object} cfg Configuration options
            @param {TinCan.Agent} cfg.agent Agent in document identifier
            @param {Function} [cfg.callback] Callback to execute on completion
            @param {String} [cfg.since] Match activity profiles saved since given timestamp
            @param {Object} [cfg.requestHeaders] Optional object containing additional headers to add to request
        @return {Array} List of profileIds for this Agent

        */
        retrieveAgentProfileIds: function (cfg) {
            this.log(&quot;retrieveAgentProfileIds&quot;);
            var requestParams = {},
                requestCfg,
                requestHeaders,
                requestResult,
                callbackWrapper;

            cfg = cfg || {};
            requestHeaders = cfg.requestHeaders || {};

            requestCfg = {
                method: &quot;GET&quot;,
                params: requestParams,
                headers: requestHeaders,
                ignore404: true
            };

            if (this.version === &quot;0.9&quot;) {
                requestCfg.url = &quot;actors/profile&quot;;
                requestParams.actor = JSON.stringify(cfg.agent.asVersion(this.version));
            }
            else {
                requestCfg.url = &quot;agents/profile&quot;;
                requestParams.agent = JSON.stringify(cfg.agent.asVersion(this.version));
            }
            if (typeof cfg.callback !== &quot;undefined&quot;) {
                callbackWrapper = function (err, xhr) {
                    var result = xhr;

                    if (err !== null) {
                        cfg.callback(err, result);
                        return;
                    }

                    if (xhr.status === 404) {
                        result = [];
                    }
                    else {
                        try {
                            result = JSON.parse(xhr.responseText);
                        }
                        catch (ex) {
                            err = &quot;Response JSON parse error: &quot; + ex;
                        }
                    }

                    cfg.callback(err, result);
                };
                requestCfg.callback = callbackWrapper;
            }
            if (typeof cfg.since !== &quot;undefined&quot;) {
                requestCfg.params.since = cfg.since;
            }

            requestResult = this.sendRequest(requestCfg);
            if (! callbackWrapper) {
                requestResult.profileIds = null;
                if (requestResult.err !== null) {
                    return requestResult;
                }

                if (requestResult.xhr.status === 404) {
                    requestResult.profileIds = [];
                }
                else {
                    try {
                        requestResult.profileIds = JSON.parse(requestResult.xhr.responseText);
                    }
                    catch (ex) {
                        requestResult.err = &quot;retrieveAgentProfileIds - JSON parse error: &quot; + ex;
                    }
                }
            }
            return requestResult;
        },

        /**
        Save an agent profile value, when used from a browser sends to the endpoint using the RESTful interface.

        @method saveAgentProfile
        @param {String} key Key of agent profile to retrieve
        @param val Value to be stored
        @param {Object} cfg Configuration options
            @param {TinCan.Agent} cfg.agent Agent in document identifier
            @param {String} [cfg.lastSHA1] SHA1 of the previously seen existing profile
            @param {String} [cfg.contentType] Content-Type to specify in headers (defaults to &#x27;application/octet-stream&#x27;)
            @param {String} [cfg.method] Method to use. Default: PUT
            @param {Function} [cfg.callback] Callback to execute on completion
            @param {Object} [cfg.requestHeaders] Optional object containing additional headers to add to request
        */
        saveAgentProfile: function (key, val, cfg) {
            this.log(&quot;saveAgentProfile&quot;);
            var requestCfg,
                requestHeaders;

            requestHeaders = cfg.requestHeaders || {};

            if (typeof cfg.contentType === &quot;undefined&quot;) {
                cfg.contentType = &quot;application/octet-stream&quot;;
            }
            requestHeaders[&quot;Content-Type&quot;] = cfg.contentType;

            if (typeof cfg.method === &quot;undefined&quot; || cfg.method !== &quot;POST&quot;) {
                cfg.method = &quot;PUT&quot;;
            }

            if (typeof val === &quot;object&quot; &amp;&amp; TinCan.Utils.isApplicationJSON(cfg.contentType)) {
                val = JSON.stringify(val);
            }

            requestCfg = {
                method: cfg.method,
                params: {
                    profileId: key
                },
                data: val,
                headers: requestHeaders
            };

            if (this.version === &quot;0.9&quot;) {
                requestCfg.url = &quot;actors/profile&quot;;
                requestCfg.params.actor = JSON.stringify(cfg.agent.asVersion(this.version));
            }
            else {
                requestCfg.url = &quot;agents/profile&quot;;
                requestCfg.params.agent = JSON.stringify(cfg.agent.asVersion(this.version));
            }
            if (typeof cfg.callback !== &quot;undefined&quot;) {
                requestCfg.callback = cfg.callback;
            }
            if (typeof cfg.lastSHA1 !== &quot;undefined&quot; &amp;&amp; cfg.lastSHA1 !== null) {
                requestCfg.headers[&quot;If-Match&quot;] = cfg.lastSHA1;
            }
            else {
                requestCfg.headers[&quot;If-None-Match&quot;] = &quot;*&quot;;
            }

            return this.sendRequest(requestCfg);
        },

        /**
        Drop an agent profile value, when used from a browser sends to the endpoint using the RESTful interface. Full agent profile
        delete is not supported by the spec.

        @method dropAgentProfile
        @param {String|null} key Key of agent profile to delete
        @param {Object} cfg Configuration options
            @param {TinCan.Agent} cfg.agent Agent in document identifier
            @param {Function} [cfg.callback] Callback to execute on completion
            @param {Object} [cfg.requestHeaders] Optional object containing additional headers to add to request
        */
        dropAgentProfile: function (key, cfg) {
            this.log(&quot;dropAgentProfile&quot;);
            var requestParams,
                requestCfg,
                requestHeaders;

            requestHeaders = cfg.requestHeaders || {};

            requestParams = {
                profileId: key
            };
            requestCfg = {
                method: &quot;DELETE&quot;,
                params: requestParams,
                headers: requestHeaders
            };

            if (this.version === &quot;0.9&quot;) {
                requestCfg.url = &quot;actors/profile&quot;;
                requestParams.actor = JSON.stringify(cfg.agent.asVersion(this.version));
            }
            else {
                requestCfg.url = &quot;agents/profile&quot;;
                requestParams.agent = JSON.stringify(cfg.agent.asVersion(this.version));
            }
            if (typeof cfg.callback !== &quot;undefined&quot;) {
                requestCfg.callback = cfg.callback;
            }

            return this.sendRequest(requestCfg);
        }
    };

    /**
    Allows client code to determine whether their environment supports synchronous xhr handling
    @static this is a static property, set by the environment
    */
    LRS.syncEnabled = null;
}());

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
