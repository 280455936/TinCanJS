<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/LRS.js - TinCanJS</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="http://cdn4.tincanapi.com/wp-content/themes/tincanapi/images/logo.png" title="TinCanJS"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.5.6</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/TinCan.html">TinCan</a></li>
            
                <li><a href="../classes/TinCan.Activity.html">TinCan.Activity</a></li>
            
                <li><a href="../classes/TinCan.ActivityDefinition.html">TinCan.ActivityDefinition</a></li>
            
                <li><a href="../classes/TinCan.ActivityProfile.html">TinCan.ActivityProfile</a></li>
            
                <li><a href="../classes/TinCan.Agent.html">TinCan.Agent</a></li>
            
                <li><a href="../classes/TinCan.AgentAccount.html">TinCan.AgentAccount</a></li>
            
                <li><a href="../classes/TinCan.Context.html">TinCan.Context</a></li>
            
                <li><a href="../classes/TinCan.ContextActivities.html">TinCan.ContextActivities</a></li>
            
                <li><a href="../classes/TinCan.Group.html">TinCan.Group</a></li>
            
                <li><a href="../classes/TinCan.InteractionComponent.html">TinCan.InteractionComponent</a></li>
            
                <li><a href="../classes/TinCan.LRS.html">TinCan.LRS</a></li>
            
                <li><a href="../classes/TinCan.Result.html">TinCan.Result</a></li>
            
                <li><a href="../classes/TinCan.Score.html">TinCan.Score</a></li>
            
                <li><a href="../classes/TinCan.State.html">TinCan.State</a></li>
            
                <li><a href="../classes/TinCan.Statement.html">TinCan.Statement</a></li>
            
                <li><a href="../classes/TinCan.StatementRef.html">TinCan.StatementRef</a></li>
            
                <li><a href="../classes/TinCan.StatementsResult.html">TinCan.StatementsResult</a></li>
            
                <li><a href="../classes/TinCan.SubStatement.html">TinCan.SubStatement</a></li>
            
                <li><a href="../classes/TinCan.Utils.html">TinCan.Utils</a></li>
            
                <li><a href="../classes/TinCan.Verb.html">TinCan.Verb</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/TinCan.html">TinCan</a></li>
            
                <li><a href="../modules/TinCan.Activity.html">TinCan.Activity</a></li>
            
                <li><a href="../modules/TinCan.ActivityDefinition.html">TinCan.ActivityDefinition</a></li>
            
                <li><a href="../modules/TinCan.ActivityProfile.html">TinCan.ActivityProfile</a></li>
            
                <li><a href="../modules/TinCan.Agent.html">TinCan.Agent</a></li>
            
                <li><a href="../modules/TinCan.AgentAccount.html">TinCan.AgentAccount</a></li>
            
                <li><a href="../modules/TinCan.Context.html">TinCan.Context</a></li>
            
                <li><a href="../modules/TinCan.ContextActivities.html">TinCan.ContextActivities</a></li>
            
                <li><a href="../modules/TinCan.Group.html">TinCan.Group</a></li>
            
                <li><a href="../modules/TinCan.InteractionComponent.html">TinCan.InteractionComponent</a></li>
            
                <li><a href="../modules/TinCan.LRS.html">TinCan.LRS</a></li>
            
                <li><a href="../modules/TinCan.Result.html">TinCan.Result</a></li>
            
                <li><a href="../modules/TinCan.Score.html">TinCan.Score</a></li>
            
                <li><a href="../modules/TinCan.State.html">TinCan.State</a></li>
            
                <li><a href="../modules/TinCan.Statement.html">TinCan.Statement</a></li>
            
                <li><a href="../modules/TinCan.StatementRef.html">TinCan.StatementRef</a></li>
            
                <li><a href="../modules/TinCan.StatementsResult.html">TinCan.StatementsResult</a></li>
            
                <li><a href="../modules/TinCan.SubStatement.html">TinCan.SubStatement</a></li>
            
                <li><a href="../modules/TinCan.Utils.html">TinCan.Utils</a></li>
            
                <li><a href="../modules/TinCan.Verb.html">TinCan.Verb</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: src/LRS.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/*
    Copyright 2012 Rustici Software

    Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
*/

/**
TinCan client library

@module TinCan
@submodule TinCan.LRS
**/
(function () {
    &quot;use strict&quot;;
    var XDR = &quot;xdr&quot;,
        NATIVE = &quot;native&quot;,

    /**
    @class TinCan.LRS
    @constructor
    */
    LRS = TinCan.LRS = function (cfg) {
        this.log(&quot;constructor&quot;);

        /**
        @property endpoint
        @type String
        */
        this.endpoint = null;

        /**
        @property version
        @type String
        */
        this.version = null;

        /**
        @property auth
        @type String
        */
        this.auth = null;

        /**
        @property allowFail
        @type Boolean
        @default true
        */
        this.allowFail = true;

        /**
        @property alertOnRequestFailure
        @type Boolean
        @default true
        */
        this.alertOnRequestFailure = true;

        /**
        @property extended
        @type Object
        */
        this.extended = null;

        /**
        @property _requestMode
        @type String
        @default &quot;native&quot;
        @private
        */
        this._requestMode = NATIVE;

        this.init(cfg);
    };
    LRS.prototype = {
        /**
        @property LOG_SRC
        */
        LOG_SRC: &quot;LRS&quot;,

        /**
        @method log
        */
        log: TinCan.prototype.log,

        /**
        @method init
        */
        init: function (cfg) {
            /*jslint regexp: true */
            this.log(&quot;init&quot;);

            var urlParts,
                schemeMatches,
                locationPort,
                isXD,
                env = TinCan.environment()
            ;

            cfg = cfg || {};

            if (! cfg.hasOwnProperty(&quot;endpoint&quot;)) {
                if (env.isBrowser &amp;&amp; this.alertOnRequestFailure) {
                    alert(&quot;[error] LRS invalid: no endpoint&quot;);
                }
                throw {
                    code: 3,
                    mesg: &quot;LRS invalid: no endpoint&quot;
                };
            }

            this.endpoint = cfg.endpoint;

            if (cfg.hasOwnProperty(&quot;allowFail&quot;)) {
                this.allowFail = cfg.allowFail;
            }

            if (cfg.hasOwnProperty(&quot;auth&quot;)) {
                this.auth = cfg.auth;
            }
            else if (cfg.hasOwnProperty(&quot;username&quot;) &amp;&amp; cfg.hasOwnProperty(&quot;password&quot;)) {
                this.auth = &quot;Basic &quot; + TinCan.Utils.getBase64String(cfg.username + &quot;:&quot; + cfg.password);
            }

            if (cfg.hasOwnProperty(&quot;extended&quot;)) {
                this.extended = cfg.extended;
            }

            urlParts = cfg.endpoint.toLowerCase().match(/([A-Za-z]+:)\/\/([^:\/]+):?(\d+)?(\/.*)?$/);

            if (env.isBrowser) {
                //
                // determine whether this is a cross domain request,
                // whether our browser has CORS support at all, and then
                // if it does then if we are in IE with XDR only check that
                // the schemes match to see if we should be able to talk to
                // the LRS
                //
                locationPort = location.port;
                schemeMatches = location.protocol.toLowerCase() === urlParts[1];

                //
                // normalize the location.port cause it appears to be &quot;&quot; when 80/443
                // but our endpoint may have provided it
                //
                if (locationPort === &quot;&quot;) {
                    locationPort = (location.protocol.toLowerCase() === &quot;http:&quot; ? &quot;80&quot; : (location.protocol.toLowerCase() === &quot;https:&quot; ? &quot;443&quot; : &quot;&quot;));
                }

                isXD = (
                    // is same scheme?
                    ! schemeMatches

                    // is same host?
                    || location.hostname.toLowerCase() !== urlParts[2]

                    // is same port?
                    || locationPort !== (
                        urlParts[3] !== null ? urlParts[3] : (urlParts[1] === &quot;http:&quot; ? &quot;80&quot; : (urlParts[1] === &quot;https:&quot; ? &quot;443&quot; : &quot;&quot;))
                    )
                );
                if (isXD) {
                    if (env.hasCORS) {
                        if (env.useXDR &amp;&amp; schemeMatches) {
                            this._requestMode = XDR;
                        }
                        else if (env.useXDR &amp;&amp; ! schemeMatches) {
                            if (cfg.allowFail) {
                                if (this.alertOnRequestFailure) {
                                    alert(&quot;[warning] LRS invalid: cross domain request for differing scheme in IE with XDR&quot;);
                                }
                            }
                            else {
                                if (this.alertOnRequestFailure) {
                                    alert(&quot;[error] LRS invalid: cross domain request for differing scheme in IE with XDR&quot;);
                                }
                                throw {
                                    code: 2,
                                    mesg: &quot;LRS invalid: cross domain request for differing scheme in IE with XDR&quot;
                                };
                            }
                        }
                    }
                    else {
                        if (cfg.allowFail) {
                            if (this.alertOnRequestFailure) {
                                alert(&quot;[warning] LRS invalid: cross domain requests not supported in this browser&quot;);
                            }
                        }
                        else {
                            if (this.alertOnRequestFailure) {
                                alert(&quot;[error] LRS invalid: cross domain requests not supported in this browser&quot;);
                            }
                            throw {
                                code: 2,
                                mesg: &quot;LRS invalid: cross domain requests not supported in this browser&quot;
                            };
                        }
                    }
                }
            }
            else {
                this.log(&quot;Unrecognized environment not supported: &quot; + env);
            }

            if (typeof cfg.version !== &quot;undefined&quot;) {
                this.log(&quot;version: &quot; + cfg.version);
                this.version = cfg.version;
            }
            else {
                //
                // assume max supported when not specified,
                // TODO: add detection of LRS from call to endpoint
                //
                this.version = TinCan.versions()[0];
            }
        },

        /**
        Method used to send a request via browser objects to the LRS

        @method sendRequest
        @param {Object} [cfg] Configuration for request
            @param {String} [cfg.url] URL portion to add to endpoint
            @param {String} [cfg.method] GET, PUT, POST, etc.
            @param {Object} [cfg.params] Parameters to set on the querystring
            @param {String} [cfg.data] String of body content
            @param {Object} [cfg.headers] Additional headers to set in the request
            @param {Function} [cfg.callback] Function to run at completion
                @param {String|Null} cfg.callback.err If an error occurred, this parameter will contain the HTTP status code.
                    If the operation succeeded, err will be null.
                @param {Object} cfg.callback.xhr XHR object
            @param {Boolean} [cfg.ignore404] Whether 404 status codes should be considered an error
        @return {Object} XHR if called in a synchronous way (in other words no callback)
        */
        sendRequest: function (cfg) {
            this.log(&quot;sendRequest&quot;);
            var xhr,
                finished = false,
                location = window.location,
                fullUrl = this.endpoint + cfg.url,
                headers = {},
                data,
                requestCompleteResult,
                until,
                prop,
                pairs = [],
                self = this
            ;

            // respect absolute URLs passed in
            if (cfg.url.indexOf(&quot;http&quot;) === 0) {
                fullUrl = cfg.url;
            }

            // add extended LMS-specified values to the params
            if (this.extended !== null) {
                cfg.params = cfg.params || {};

                for (prop in this.extended) {
                    if (this.extended.hasOwnProperty(prop)) {
                        // don&#x27;t overwrite cfg.params values that have already been added to the request with our extended params
                        if (! cfg.params.hasOwnProperty(prop)) {
                            if (this.extended[prop] !== null) {
                                cfg.params[prop] = this.extended[prop];
                            }
                        }
                    }
                }
            }

            // consolidate headers
            headers[&quot;Content-Type&quot;] = &quot;application/json&quot;;
            headers.Authorization = this.auth;
            if (this.version !== &quot;0.9&quot;) {
                headers[&quot;X-Experience-API-Version&quot;] = this.version;
            }

            for (prop in cfg.headers) {
                if (cfg.headers.hasOwnProperty(prop)) {
                    headers[prop] = cfg.headers[prop];
                }
            }

            if (this._requestMode === NATIVE) {
                this.log(&quot;sendRequest using XMLHttpRequest&quot;);

                for (prop in cfg.params) {
                    if (cfg.params.hasOwnProperty(prop)) {
                        pairs.push(prop + &quot;=&quot; + encodeURIComponent(cfg.params[prop]));
                    }
                }
                if (pairs.length &gt; 0) {
                    fullUrl += &quot;?&quot; + pairs.join(&quot;&amp;&quot;);
                }

                this.log(&quot;sendRequest using XMLHttpRequest - async: &quot; + (typeof cfg.callback !== &quot;undefined&quot;));

                xhr = new XMLHttpRequest();
                xhr.open(cfg.method, fullUrl, (typeof cfg.callback !== &quot;undefined&quot;));
                for (prop in headers) {
                    if (headers.hasOwnProperty(prop)) {
                        xhr.setRequestHeader(prop, headers[prop]);
                    }
                }

                if (typeof cfg.data !== &quot;undefined&quot;) {
                    cfg.data += &quot;&quot;;
                }
                data = cfg.data;
            }
            else if (this._requestMode === XDR) {
                this.log(&quot;sendRequest using XDomainRequest&quot;);

                // method has to go on querystring, and nothing else,
                // and the actual method is then always POST
                fullUrl += &quot;?method=&quot; + cfg.method;

                // params end up in the body
                for (prop in cfg.params) {
                    if (cfg.params.hasOwnProperty(prop)) {
                        pairs.push(prop + &quot;=&quot; + encodeURIComponent(cfg.params[prop]));
                    }
                }

                // headers go into form data
                for (prop in headers) {
                    if (headers.hasOwnProperty(prop)) {
                        pairs.push(prop + &quot;=&quot; + encodeURIComponent(headers[prop]));
                    }
                }

                // the original data is repackaged as &quot;content&quot; form var
                if (cfg.data !== null) {
                    pairs.push(&quot;content=&quot; + encodeURIComponent(cfg.data));
                }

                data = pairs.join(&quot;&amp;&quot;);

                xhr = new XDomainRequest ();
                xhr.open(&quot;POST&quot;, fullUrl);
            }
            else {
                this.log(&quot;sendRequest unrecognized _requestMode: &quot; + this._requestMode);
            }

            // Setup request callback
            function requestComplete () {
                self.log(&quot;requestComplete: &quot; + finished + &quot;, xhr.status: &quot; + xhr.status);
                var notFoundOk,
                    httpStatus;

                //
                // older versions of IE don&#x27;t properly handle 204 status codes
                // so correct when receiving a 1223 to be 204 locally
                // http://stackoverflow.com/questions/10046972/msie-returns-status-code-of-1223-for-ajax-request
                //
                httpStatus = (xhr.status === 1223) ? 204 : xhr.status;

                if (! finished) {
                    // may be in sync or async mode, using XMLHttpRequest or IE XDomainRequest, onreadystatechange or
                    // onload or both might fire depending upon browser, just covering all bases with event hooks and
                    // using &#x27;finished&#x27; flag to avoid triggering events multiple times
                    finished = true;

                    notFoundOk = (cfg.ignore404 &amp;&amp; httpStatus === 404);
                    if (httpStatus === undefined || (httpStatus &gt;= 200 &amp;&amp; httpStatus &lt; 400) || notFoundOk) {
                        if (cfg.callback) {
                            cfg.callback(null, xhr);
                        }
                        else {
                            requestCompleteResult = {
                                err: null,
                                xhr: xhr
                            };
                            return requestCompleteResult;
                        }
                    }
                    else {
                        // Alert all errors except cancelled XHR requests
                        if (httpStatus &gt; 0) {
                            requestCompleteResult = {
                                err: httpStatus,
                                xhr: xhr
                            };
                            if (self.alertOnRequestFailure) {
                                alert(&quot;[warning] There was a problem communicating with the Learning Record Store. (&quot; + httpStatus + &quot; | &quot; + xhr.responseText+ &quot;)&quot;);
                            }
                            if (cfg.callback) {
                                cfg.callback(httpStatus, xhr);
                            }
                        }
                        return requestCompleteResult;
                    }
                }
                else {
                    return requestCompleteResult;
                }
            }

            xhr.onreadystatechange = function () {
                self.log(&quot;xhr.onreadystatechange - xhr.readyState: &quot; + finished + &quot;, xhr.status: &quot; + xhr.status);
                if (xhr.readyState === 4) {
                    requestComplete();
                }
            };

            xhr.onload = requestComplete;
            xhr.onerror = requestComplete;

            xhr.send(data);

            if (! cfg.callback) {
                // synchronous
                if (this._requestMode === XDR) {
                    // synchronous call in IE, with no synchronous mode available
                    until = 1000 + Date.now();
                    this.log(&quot;sendRequest - until: &quot; + until + &quot;, finished: &quot; + finished);

                    while (Date.now() &lt; until &amp;&amp; ! finished) {
                        //this.log(&quot;calling __delay&quot;);
                        this.__delay();
                    }
                }
                return requestComplete();
            }

            //
            // for async requests give them the XHR object directly
            // as the return value, the actual stuff they should be
            // caring about is params to the callback, for sync
            // requests they got the return value above
            //
            return xhr;
        },

        /**
        Save a statement, when used from a browser sends to the endpoint using the RESTful interface.
        Use a callback to make the call asynchronous.

        @method saveStatement
        @param {Object} TinCan.Statement to send
        @param {Object} [cfg] Configuration used when saving
            @param {Function} [cfg.callback] Callback to execute on completion
        */
        saveStatement: function (stmt, cfg) {
            this.log(&quot;saveStatement&quot;);
            var requestCfg;

            // TODO: it would be better to make a subclass that knows
            //       its own environment and just implements the protocol
            //       that it needs to
            if (! TinCan.environment().isBrowser) {
                this.log(&quot;error: environment not implemented&quot;);
                return;
            }

            cfg = cfg || {};

            requestCfg = {
                url: &quot;statements&quot;,
                data: JSON.stringify(stmt.asVersion( this.version ))
            };
            if (stmt.id !== null) {
                requestCfg.method = &quot;PUT&quot;;
                requestCfg.params = {
                    statementId: stmt.id
                };
            }
            else {
                requestCfg.method = &quot;POST&quot;;
            }

            if (typeof cfg.callback !== &quot;undefined&quot;) {
                requestCfg.callback = cfg.callback;
            }

            return this.sendRequest(requestCfg);
        },

        /**
        Retrieve a statement, when used from a browser sends to the endpoint using the RESTful interface.

        @method retrieveStatement
        @param {String} ID of statement to retrieve
        @param {Object} [cfg] Configuration options
            @param {Function} [cfg.callback] Callback to execute on completion
        @return {Object} TinCan.Statement retrieved
        */
        retrieveStatement: function (stmtId, cfg) {
            this.log(&quot;retrieveStatement&quot;);
            var requestCfg,
                requestResult,
                callbackWrapper;

            // TODO: it would be better to make a subclass that knows
            //       its own environment and just implements the protocol
            //       that it needs to
            if (! TinCan.environment().isBrowser) {
                this.log(&quot;error: environment not implemented&quot;);
                return;
            }

            cfg = cfg || {};

            requestCfg = {
                url: &quot;statements&quot;,
                method: &quot;GET&quot;,
                params: {
                    statementId: stmtId
                }
            };
            if (typeof cfg.callback !== &quot;undefined&quot;) {
                callbackWrapper = function (err, xhr) {
                    var result = xhr;

                    if (err === null) {
                        result = TinCan.Statement.fromJSON(xhr.responseText);
                    }

                    cfg.callback(err, result);
                };
                requestCfg.callback = callbackWrapper;
            }

            requestResult = this.sendRequest(requestCfg);
            if (! callbackWrapper) {
                requestResult.statement = null;
                if (requestResult.err === null) {
                    requestResult.statement = TinCan.Statement.fromJSON(requestResult.xhr.responseText);
                }
            }

            return requestResult;
        },

        /**
        Retrieve a voided statement, when used from a browser sends to the endpoint using the RESTful interface.

        @method retrieveVoidedStatement
        @param {String} ID of voided statement to retrieve
        @param {Object} [cfg] Configuration options
            @param {Function} [cfg.callback] Callback to execute on completion
        @return {Object} TinCan.Statement retrieved
        */
        retrieveVoidedStatement: function (stmtId, cfg) {
            this.log(&quot;retrieveStatement&quot;);
            var requestCfg,
                requestResult,
                callbackWrapper;

            // TODO: it would be better to make a subclass that knows
            //       its own environment and just implements the protocol
            //       that it needs to
            if (! TinCan.environment().isBrowser) {
                this.log(&quot;error: environment not implemented&quot;);
                return;
            }

            cfg = cfg || {};

            requestCfg = {
                url: &quot;statements&quot;,
                method: &quot;GET&quot;,
                params: {}
            };
            if (this.version === &quot;0.9&quot; || this.version === &quot;0.95&quot;) {
                requestCfg.params.statementId = stmtId;
            }
            else {
                requestCfg.params.voidedStatementId = stmtId;
            }

            if (typeof cfg.callback !== &quot;undefined&quot;) {
                callbackWrapper = function (err, xhr) {
                    var result = xhr;

                    if (err === null) {
                        result = TinCan.Statement.fromJSON(xhr.responseText);
                    }

                    cfg.callback(err, result);
                };
                requestCfg.callback = callbackWrapper;
            }

            requestResult = this.sendRequest(requestCfg);
            if (! callbackWrapper) {
                requestResult.statement = null;
                if (requestResult.err === null) {
                    requestResult.statement = TinCan.Statement.fromJSON(requestResult.xhr.responseText);
                }
            }

            return requestResult;
        },

        /**
        Save a set of statements, when used from a browser sends to the endpoint using the RESTful interface.
        Use a callback to make the call asynchronous.

        @method saveStatements
        @param {Array} Array of statements or objects convertable to statements
        @param {Object} [cfg] Configuration used when saving
            @param {Function} [cfg.callback] Callback to execute on completion
        */
        saveStatements: function (stmts, cfg) {
            this.log(&quot;saveStatements&quot;);
            var requestCfg,
                versionedStatements = [],
                i
            ;

            // TODO: it would be better to make a subclass that knows
            //       its own environment and just implements the protocol
            //       that it needs to
            if (! TinCan.environment().isBrowser) {
                this.log(&quot;error: environment not implemented&quot;);
                return;
            }

            cfg = cfg || {};

            if (stmts.length === 0) {
                if (typeof cfg.callback !== &quot;undefined&quot;) {
                    cfg.callback.apply(this, [&quot;no statements&quot;]);
                }
                return;
            }

            for (i = 0; i &lt; stmts.length; i += 1) {
                versionedStatements.push(
                    stmts[i].asVersion( this.version )
                );
            }

            requestCfg = {
                url: &quot;statements&quot;,
                method: &quot;POST&quot;,
                data: JSON.stringify(versionedStatements)
            };
            if (typeof cfg.callback !== &quot;undefined&quot;) {
                requestCfg.callback = cfg.callback;
            }

            return this.sendRequest(requestCfg);
        },

        /**
        Fetch a set of statements, when used from a browser sends to the endpoint using the
        RESTful interface.  Use a callback to make the call asynchronous.

        @method queryStatements
        @param {Object} [cfg] Configuration used to query
            @param {Object} [cfg.params] Query parameters
                @param {TinCan.Agent|TinCan.Group} [cfg.params.agent] Agent matches &#x27;actor&#x27; or &#x27;object&#x27;
                @param {TinCan.Verb} [cfg.params.verb] Verb to query on
                @param {TinCan.Activity} [cfg.params.activity] Activity to query on
                @param {String} [cfg.params.registration] Registration UUID
                @param {Boolean} [cfg.params.related_activities] Match related activities
                @param {Boolean} [cfg.params.related_agents] Match related agents
                @param {String} [cfg.params.since] Match statements stored since specified timestamp
                @param {String} [cfg.params.until] Match statements stored at or before specified timestamp
                @param {Integer} [cfg.params.limit] Number of results to retrieve
                @param {String} [cfg.params.format] One of &quot;ids&quot;, &quot;exact&quot;, &quot;canonical&quot; (default: &quot;exact&quot;)
                @param {Boolean} [cfg.params.attachments] Include attachments in multipart response or don&#x27;t (defualt: false)
                @param {Boolean} [cfg.params.ascending] Return results in ascending order of stored time

                @param {TinCan.Agent} [cfg.params.actor] (Removed in 1.0.0, use &#x27;agent&#x27; instead) Agent matches &#x27;actor&#x27;
                @param {TinCan.Activity|TinCan.Agent|TinCan.Statement} [cfg.params.target] (Removed in 1.0.0, use &#x27;activity&#x27; or &#x27;agent&#x27; instead) Activity, Agent, or Statement matches &#x27;object&#x27;
                @param {TinCan.Agent} [cfg.params.instructor] (Removed in 1.0.0, use &#x27;agent&#x27; + &#x27;related_agents&#x27; instead) Agent matches &#x27;context:instructor&#x27;
                @param {Boolean} [cfg.params.context] (Removed in 1.0.0, use &#x27;activity&#x27; instead) When filtering on target, include statements with matching context
                @param {Boolean} [cfg.params.authoritative] (Removed in 1.0.0) Get authoritative results
                @param {Boolean} [cfg.params.sparse] (Removed in 1.0.0, use &#x27;format&#x27; instead) Get sparse results

            @param {Function} [cfg.callback] Callback to execute on completion
                @param {String|null} cfg.callback.err Error status or null if succcess
                @param {TinCan.StatementsResult|XHR} cfg.callback.response Receives a StatementsResult argument
        @return {Object} Request result
        */
        queryStatements: function (cfg) {
            this.log(&quot;queryStatements&quot;);
            var requestCfg,
                requestResult,
                callbackWrapper;

            // TODO: it would be better to make a subclass that knows
            //       its own environment and just implements the protocol
            //       that it needs to
            if (! TinCan.environment().isBrowser) {
                this.log(&quot;error: environment not implemented&quot;);
                return;
            }

            cfg = cfg || {};
            cfg.params = cfg.params || {};

            //
            // if they misconfigured (possibly do to version mismatches) the
            // query then don&#x27;t try to send a request at all, rather than give
            // them invalid results
            //
            try {
                requestCfg = this._queryStatementsRequestCfg(cfg);
            }
            catch (ex) {
                if (TinCan.environment().isBrowser &amp;&amp; this.alertOnRequestFailure) {
                    alert(&quot;[error] Query statements failed - &quot; + ex);
                }
                if (typeof cfg.callback !== &quot;undefined&quot;) {
                    cfg.callback(ex, {});
                }

                return {
                    err: ex,
                    statementsResult: null
                };
            }

            if (typeof cfg.callback !== &quot;undefined&quot;) {
                callbackWrapper = function (err, xhr) {
                    var result = xhr;

                    if (err === null) {
                        result = TinCan.StatementsResult.fromJSON(xhr.responseText);
                    }

                    cfg.callback(err, result);
                };
                requestCfg.callback = callbackWrapper;
            }

            requestResult = this.sendRequest(requestCfg);
            requestResult.config = requestCfg;

            if (! callbackWrapper) {
                requestResult.statementsResult = null;
                if (requestResult.err === null) {
                    requestResult.statementsResult = TinCan.StatementsResult.fromJSON(requestResult.xhr.responseText);
                }
            }

            return requestResult;
        },

        /**
        Build a request config object that can be passed to sendRequest() to make a query request

        @method _queryStatementsRequestCfg
        @private
        @param {Object} [cfg] See configuration for {{#crossLink &quot;TinCan.LRS/queryStatements&quot;}}{{/crossLink}}
        @return {Object} Request configuration object
        */
        _queryStatementsRequestCfg: function (cfg) {
            this.log(&quot;_queryStatementsRequestCfg&quot;);
            var params = {},
                returnCfg = {
                    url: &quot;statements&quot;,
                    method: &quot;GET&quot;,
                    params: params
                },
                jsonProps = [
                    &quot;agent&quot;,
                    &quot;actor&quot;,
                    &quot;object&quot;,
                    &quot;instructor&quot;
                ],
                idProps = [
                    &quot;verb&quot;,
                    &quot;activity&quot;
                ],
                valProps = [
                    &quot;registration&quot;,
                    &quot;context&quot;,
                    &quot;since&quot;,
                    &quot;until&quot;,
                    &quot;limit&quot;,
                    &quot;authoritative&quot;,
                    &quot;sparse&quot;,
                    &quot;ascending&quot;,
                    &quot;related_activities&quot;,
                    &quot;related_agents&quot;,
                    &quot;format&quot;,
                    &quot;attachments&quot;
                ],
                i,
                prop,
                //
                // list of parameters that are supported in all versions (supported by
                // this library) of the spec
                //
                universal = {
                    verb: true,
                    registration: true,
                    since: true,
                    until: true,
                    limit: true,
                    ascending: true
                },
                //
                // future proofing here, &quot;supported&quot; is an object so that
                // in the future we can support a &quot;deprecated&quot; list to
                // throw warnings, hopefully the spec uses deprecation phases
                // for the removal of these things
                //
                compatibility = {
                    &quot;0.9&quot;: {
                        supported: {
                            actor: true,
                            instructor: true,
                            target: true,
                            object: true,
                            context: true,
                            authoritative: true,
                            sparse: true
                        }
                    },
                    &quot;1.0.0&quot;: {
                        supported: {
                            agent: true,
                            activity: true,
                            related_activities: true,
                            related_agents: true,
                            format: true,
                            attachments: true
                        }
                    }
                };

            compatibility[&quot;0.95&quot;] = compatibility[&quot;0.9&quot;];

            if (cfg.params.hasOwnProperty(&quot;target&quot;)) {
                cfg.params.object = cfg.params.target;
            }

            //
            // check compatibility tables, either the configured parameter is in
            // the universal list or the specific version, if not then throw an
            // error which at least for .queryStatements will prevent the request
            // and potentially alert the user
            //
            for (prop in cfg.params) {
                if (cfg.params.hasOwnProperty(prop)) {
                    if (typeof universal[prop] === &quot;undefined&quot; &amp;&amp; typeof compatibility[this.version].supported[prop] === &quot;undefined&quot;) {
                        throw &quot;Unrecognized query parameter configured: &quot; + prop;
                    }
                }
            }

            //
            // getting here means that all parameters are valid for this version
            // to make handling the output formats easier
            //

            for (i = 0; i &lt; jsonProps.length; i += 1) {
                if (typeof cfg.params[jsonProps[i]] !== &quot;undefined&quot;) {
                    params[jsonProps[i]] = JSON.stringify(cfg.params[jsonProps[i]].asVersion(this.version));
                }
            }

            for (i = 0; i &lt; idProps.length; i += 1) {
                if (typeof cfg.params[idProps[i]] !== &quot;undefined&quot;) {
                    params[idProps[i]] = cfg.params[idProps[i]].id;
                }
            }

            for (i = 0; i &lt; valProps.length; i += 1) {
                if (typeof cfg.params[valProps[i]] !== &quot;undefined&quot;) {
                    params[valProps[i]] = cfg.params[valProps[i]];
                }
            }

            return returnCfg;
        },

        /**
        Fetch more statements from a previous query, when used from a browser sends to the endpoint using the
        RESTful interface.  Use a callback to make the call asynchronous.

        @method moreStatements
        @param {Object} [cfg] Configuration used to query
            @param {String} [cfg.url] More URL
            @param {Function} [cfg.callback] Callback to execute on completion
                @param {String|null} cfg.callback.err Error status or null if succcess
                @param {TinCan.StatementsResult|XHR} cfg.callback.response Receives a StatementsResult argument
        @return {Object} Request result
        */
        moreStatements: function (cfg) {
            this.log(&quot;moreStatements: &quot; + cfg.url);
            var requestCfg,
                requestResult,
                callbackWrapper,
                parsedURL,
                serverRoot;

            // TODO: it would be better to make a subclass that knows
            //       its own environment and just implements the protocol
            //       that it needs to
            if (! TinCan.environment().isBrowser) {
                this.log(&quot;error: environment not implemented&quot;);
                return;
            }

            cfg = cfg || {};

            // to support our interface (to support IE) we need to break apart
            // the more URL query params so that the request can be made properly later
            parsedURL = TinCan.Utils.parseURL(cfg.url);

            //Respect a more URL that is relative to either the server root 
            //or endpoint (though only the former is allowed in the spec)
            serverRoot = TinCan.Utils.getServerRoot(this.endpoint);
            if (parsedURL.path.indexOf(&quot;/statements&quot;) === 0){
                parsedURL.path = this.endpoint.replace(serverRoot, &#x27;&#x27;) + parsedURL.path;
                this.log(&quot;converting non-standard more URL to &quot; + parsedURL.path);
            }

            //The more relative URL might not start with a slash, add it if not
            if (parsedURL.path.indexOf(&quot;/&quot;) !== 0) {
                parsedURL.path = &quot;/&quot; + parsedURL.path;
            }

            requestCfg = {
                method: &quot;GET&quot;,
                //For arbitrary more URLs to work, 
                //we need to make the URL absolute here
                url: serverRoot + parsedURL.path,
                params: parsedURL.params
            };
            if (typeof cfg.callback !== &quot;undefined&quot;) {
                callbackWrapper = function (err, xhr) {
                    var result = xhr;

                    if (err === null) {
                        result = TinCan.StatementsResult.fromJSON(xhr.responseText);
                    }

                    cfg.callback(err, result);
                };
                requestCfg.callback = callbackWrapper;
            }

            requestResult = this.sendRequest(requestCfg);
            requestResult.config = requestCfg;

            if (! callbackWrapper) {
                requestResult.statementsResult = null;
                if (requestResult.err === null) {
                    requestResult.statementsResult = TinCan.StatementsResult.fromJSON(requestResult.xhr.responseText);
                }
            }

            return requestResult;
        },

        /**
        Retrieve a state value, when used from a browser sends to the endpoint using the RESTful interface.

        @method retrieveState
        @param {String} key Key of state to retrieve
        @param {Object} cfg Configuration options
            @param {Object} cfg.activity TinCan.Activity
            @param {Object} cfg.agent TinCan.Agent
            @param {String} [cfg.registration] Registration
            @param {Function} [cfg.callback] Callback to execute on completion
                @param {Object|Null} cfg.callback.error
                @param {TinCan.State|null} cfg.callback.result null if state is 404
        @return {Object} TinCan.State retrieved when synchronous, or result from sendRequest
        */
        retrieveState: function (key, cfg) {
            this.log(&quot;retrieveState&quot;);
            var requestParams = {},
                requestCfg = {},
                requestResult,
                callbackWrapper
            ;

            // TODO: it would be better to make a subclass that knows
            //       its own environment and just implements the protocol
            //       that it needs to
            if (! TinCan.environment().isBrowser) {
                this.log(&quot;error: environment not implemented&quot;);
                return;
            }

            requestParams = {
                stateId: key,
                activityId: cfg.activity.id
            };
            if (this.version === &quot;0.9&quot;) {
                requestParams.actor = JSON.stringify(cfg.agent.asVersion(this.version));
            }
            else {
                requestParams.agent = JSON.stringify(cfg.agent.asVersion(this.version));
            }
            if (typeof cfg.registration !== &quot;undefined&quot;) {
                if (this.version === &quot;0.9&quot;) {
                    requestParams.registrationId = cfg.registration;
                }
                else {
                    requestParams.registration = cfg.registration;
                }
            }

            requestCfg = {
                url: &quot;activities/state&quot;,
                method: &quot;GET&quot;,
                params: requestParams,
                ignore404: true
            };
            if (typeof cfg.callback !== &quot;undefined&quot;) {
                callbackWrapper = function (err, xhr) {
                    var result = xhr;

                    if (err === null) {
                        if (xhr.status === 404) {
                            result = null;
                        }
                        else {
                            result = new TinCan.State(
                                {
                                    id: key,
                                    contents: xhr.responseText
                                }
                            );
                            if (typeof xhr.getResponseHeader !== &quot;undefined&quot; &amp;&amp; xhr.getResponseHeader(&quot;ETag&quot;) !== null &amp;&amp; xhr.getResponseHeader(&quot;ETag&quot;) !== &quot;&quot;) {
                                result.etag = xhr.getResponseHeader(&quot;ETag&quot;);
                            } else {
                                //
                                // either XHR didn&#x27;t have getResponseHeader (probably cause it is an IE
                                // XDomainRequest object which doesn&#x27;t) or not populated by LRS so create
                                // the hash ourselves
                                //
                                result.etag = TinCan.Utils.getSHA1String(xhr.responseText);
                            }
                        }
                    }

                    cfg.callback(err, result);
                };
                requestCfg.callback = callbackWrapper;
            }

            requestResult = this.sendRequest(requestCfg);
            if (! callbackWrapper) {
                requestResult.state = null;
                if (requestResult.err === null &amp;&amp; requestResult.xhr.status !== 404) {
                    requestResult.state = new TinCan.State(
                        {
                            id: key,
                            contents: requestResult.xhr.responseText
                        }
                    );
                    if (typeof requestResult.xhr.getResponseHeader !== &quot;undefined&quot; &amp;&amp; requestResult.xhr.getResponseHeader(&quot;ETag&quot;) !== null &amp;&amp; requestResult.xhr.getResponseHeader(&quot;ETag&quot;) !== &quot;&quot;) {
                        requestResult.state.etag = requestResult.xhr.getResponseHeader(&quot;ETag&quot;);
                    } else {
                        //
                        // either XHR didn&#x27;t have getResponseHeader (probably cause it is an IE
                        // XDomainRequest object which doesn&#x27;t) or not populated by LRS so create
                        // the hash ourselves
                        //
                        requestResult.state.etag = TinCan.Utils.getSHA1String(requestResult.xhr.responseText);
                    }
                }
            }

            return requestResult;
        },

        /**
        Save a state value, when used from a browser sends to the endpoint using the RESTful interface.

        @method saveState
        @param {String} key Key of state to save
        @param {String} val Value of state to save
        @param {Object} cfg Configuration options
            @param {Object} cfg.activity TinCan.Activity
            @param {Object} cfg.agent TinCan.Agent
            @param {String} [cfg.registration] Registration
            @param {String} [cfg.lastSHA1] SHA1 of the previously seen existing state
            @param {Function} [cfg.callback] Callback to execute on completion
        */
        saveState: function (key, val, cfg) {
            this.log(&quot;saveState&quot;);
            var requestParams,
                requestCfg,
                requestResult
            ;

            // TODO: it would be better to make a subclass that knows
            //       its own environment and just implements the protocol
            //       that it needs to
            if (! TinCan.environment().isBrowser) {
                this.log(&quot;error: environment not implemented&quot;);
                return;
            }

            if (typeof val === &quot;object&quot;) {
                val = JSON.stringify(val);
            }

            requestParams = {
                stateId: key,
                activityId: cfg.activity.id
            };
            if (this.version === &quot;0.9&quot;) {
                requestParams.actor = JSON.stringify(cfg.agent.asVersion(this.version));
            }
            else {
                requestParams.agent = JSON.stringify(cfg.agent.asVersion(this.version));
            }
            if (typeof cfg.registration !== &quot;undefined&quot;) {
                if (this.version === &quot;0.9&quot;) {
                    requestParams.registrationId = cfg.registration;
                }
                else {
                    requestParams.registration = cfg.registration;
                }
            }

            requestCfg = {
                url: &quot;activities/state&quot;,
                method: &quot;PUT&quot;,
                params: requestParams,
                data: val
            };
            if (typeof cfg.callback !== &quot;undefined&quot;) {
                requestCfg.callback = cfg.callback;
            }
            if (typeof cfg.lastSHA1 !== &quot;undefined&quot; &amp;&amp; cfg.lastSHA1 !== null) {
                requestCfg.headers = {
                    &quot;If-Match&quot;: cfg.lastSHA1
                };
            }

            return this.sendRequest(requestCfg);
        },

        /**
        Drop a state value or all of the state, when used from a browser sends to the endpoint using the RESTful interface.

        @method dropState
        @param {String|null} key Key of state to delete, or null for all
        @param {Object} cfg Configuration options
            @param {Object} [cfg.activity] TinCan.Activity
            @param {Object} [cfg.agent] TinCan.Agent
            @param {String} [cfg.registration] Registration
            @param {Function} [cfg.callback] Callback to execute on completion
        */
        dropState: function (key, cfg) {
            this.log(&quot;dropState&quot;);
            var requestParams = {},
                requestCfg = {}
            ;

            // TODO: it would be better to make a subclass that knows
            //       its own environment and just implements the protocol
            //       that it needs to
            if (! TinCan.environment().isBrowser) {
                this.log(&quot;error: environment not implemented&quot;);
                return;
            }

            requestParams = {
                activityId: cfg.activity.id
            };
            if (this.version === &quot;0.9&quot;) {
                requestParams.actor = JSON.stringify(cfg.agent.asVersion(this.version));
            }
            else {
                requestParams.agent = JSON.stringify(cfg.agent.asVersion(this.version));
            }
            if (key !== null) {
                requestParams.stateId = key;
            }
            if (typeof cfg.registration !== &quot;undefined&quot;) {
                if (this.version === &quot;0.9&quot;) {
                    requestParams.registrationId = cfg.registration;
                }
                else {
                    requestParams.registration = cfg.registration;
                }
            }

            requestCfg = {
                url: &quot;activities/state&quot;,
                method: &quot;DELETE&quot;,
                params: requestParams
            };
            if (typeof cfg.callback !== &quot;undefined&quot;) {
                requestCfg.callback = cfg.callback;
            }

            return this.sendRequest(requestCfg);
        },

        /**
        Retrieve an activity profile value, when used from a browser sends to the endpoint using the RESTful interface.

        @method retrieveActivityProfile
        @param {String} key Key of activity profile to retrieve
        @param {Object} cfg Configuration options
            @param {Object} cfg.activity TinCan.Activity
            @param {Function} [cfg.callback] Callback to execute on completion
        @return {Object} Value retrieved
        */
        retrieveActivityProfile: function (key, cfg) {
            this.log(&quot;retrieveActivityProfile&quot;);
            var requestCfg = {},
                requestResult,
                callbackWrapper
            ;

            // TODO: it would be better to make a subclass that knows
            //       its own environment and just implements the protocol
            //       that it needs to
            if (! TinCan.environment().isBrowser) {
                this.log(&quot;error: environment not implemented&quot;);
                return;
            }

            requestCfg = {
                url: &quot;activities/profile&quot;,
                method: &quot;GET&quot;,
                params: {
                    profileId: key,
                    activityId: cfg.activity.id
                },
                ignore404: true
            };
            if (typeof cfg.callback !== &quot;undefined&quot;) {
                callbackWrapper = function (err, xhr) {
                    var result = xhr;

                    if (err === null) {
                        if (xhr.status === 404) {
                            result = null;
                        }
                        else {
                            result = new TinCan.ActivityProfile(
                                {
                                    id: key,
                                    activity: cfg.activity,
                                    contents: xhr.responseText
                                }
                            );
                            if (typeof xhr.getResponseHeader !== &quot;undefined&quot; &amp;&amp; xhr.getResponseHeader(&quot;ETag&quot;) !== null &amp;&amp; xhr.getResponseHeader(&quot;ETag&quot;) !== &quot;&quot;) {
                                result.etag = xhr.getResponseHeader(&quot;ETag&quot;);
                            } else {
                                //
                                // either XHR didn&#x27;t have getResponseHeader (probably cause it is an IE
                                // XDomainRequest object which doesn&#x27;t) or not populated by LRS so create
                                // the hash ourselves
                                //
                                result.etag = TinCan.Utils.getSHA1String(xhr.responseText);
                            }
                        }
                    }

                    cfg.callback(err, result);
                };
                requestCfg.callback = callbackWrapper;
            }

            requestResult = this.sendRequest(requestCfg);
            if (! callbackWrapper) {
                requestResult.profile = null;
                if (requestResult.err === null &amp;&amp; requestResult.xhr.status !== 404) {
                    requestResult.profile = new TinCan.ActivityProfile(
                        {
                            id: key,
                            activity: cfg.activity,
                            contents: requestResult.xhr.responseText
                        }
                    );
                    if (typeof requestResult.xhr.getResponseHeader !== &quot;undefined&quot; &amp;&amp; requestResult.xhr.getResponseHeader(&quot;ETag&quot;) !== null &amp;&amp; requestResult.xhr.getResponseHeader(&quot;ETag&quot;) !== &quot;&quot;) {
                        requestResult.profile.etag = requestResult.xhr.getResponseHeader(&quot;ETag&quot;);
                    } else {
                        //
                        // either XHR didn&#x27;t have getResponseHeader (probably cause it is an IE
                        // XDomainRequest object which doesn&#x27;t) or not populated by LRS so create
                        // the hash ourselves
                        //
                        requestResult.profile.etag = TinCan.Utils.getSHA1String(requestResult.xhr.responseText);
                    }
                }
            }

            return requestResult;
        },

        /**
        Save an activity profile value, when used from a browser sends to the endpoint using the RESTful interface.

        @method saveActivityProfile
        @param {String} key Key of activity profile to retrieve
        @param {Object} cfg Configuration options
            @param {Object} cfg.activity TinCan.Activity
            @param {String} [cfg.lastSHA1] SHA1 of the previously seen existing profile
            @param {Function} [cfg.callback] Callback to execute on completion
        */
        saveActivityProfile: function (key, val, cfg) {
            this.log(&quot;saveActivityProfile&quot;);
            var requestCfg;

            // TODO: it would be better to make a subclass that knows
            //       its own environment and just implements the protocol
            //       that it needs to
            if (! TinCan.environment().isBrowser) {
                this.log(&quot;error: environment not implemented&quot;);
                return;
            }

            if (typeof val === &quot;object&quot;) {
                val = JSON.stringify(val);
            }

            requestCfg = {
                url: &quot;activities/profile&quot;,
                method: &quot;PUT&quot;,
                params: {
                    profileId: key,
                    activityId: cfg.activity.id
                },
                data: val
            };
            if (typeof cfg.callback !== &quot;undefined&quot;) {
                requestCfg.callback = cfg.callback;
            }
            if (typeof cfg.lastSHA1 !== &quot;undefined&quot; &amp;&amp; cfg.lastSHA1 !== null) {
                requestCfg.headers = {
                    &quot;If-Match&quot;: cfg.lastSHA1
                };
            }
            else {
                requestCfg.headers = {
                    &quot;If-None-Match&quot;: &quot;*&quot;
                };
            }

            return this.sendRequest(requestCfg);
        },

        /**
        Drop an activity profile value or all of the activity profile, when used from a browser sends to the endpoint using the RESTful interface.

        @method dropActivityProfile
        @param {String|null} key Key of activity profile to delete, or null for all
        @param {Object} cfg Configuration options
            @param {Object} cfg.activity TinCan.Activity
            @param {Function} [cfg.callback] Callback to execute on completion
        */
        dropActivityProfile: function (key, cfg) {
            this.log(&quot;dropActivityProfile&quot;);
            var requestParams = {},
                requestCfg = {}
            ;

            // TODO: it would be better to make a subclass that knows
            //       its own environment and just implements the protocol
            //       that it needs to
            if (! TinCan.environment().isBrowser) {
                this.log(&quot;error: environment not implemented&quot;);
                return;
            }

            requestParams = {
                activityId: cfg.activity.id
            };
            if (key !== null) {
                requestParams.profileId = key;
            }

            requestCfg = {
                url: &quot;activities/profile&quot;,
                method: &quot;DELETE&quot;,
                params: requestParams
            };
            if (typeof cfg.callback !== &quot;undefined&quot;) {
                requestCfg.callback = cfg.callback;
            }

            return this.sendRequest(requestCfg);
        },

        /**
        Non-environment safe method used to create a delay to give impression
        of synchronous response

        @method __delay
        @private
        */
        __delay: function () {
            //
            // use a synchronous request to the current location to allow the browser
            // to yield to the asynchronous request&#x27;s events but still block in the
            // outer loop to make it seem synchronous to the end user
            //
            // removing this made the while loop too tight to allow the asynchronous
            // events through to get handled so that the response was correctly handled
            //
            var xhr = new XMLHttpRequest (),
                url = window.location + &quot;?forcenocache=&quot; + TinCan.Utils.getUUID()
            ;
            xhr.open(&quot;GET&quot;, url, false);
            xhr.send(null);
        }
    };
}());

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
