<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/TinCan.js - TinCanJS</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="http://cdn4.tincanapi.com/wp-content/themes/tincanapi/images/logo.png" title="TinCanJS"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.20.0</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/TinCan.html">TinCan</a></li>
            
                <li><a href="../classes/TinCan.Activity.html">TinCan.Activity</a></li>
            
                <li><a href="../classes/TinCan.ActivityDefinition.html">TinCan.ActivityDefinition</a></li>
            
                <li><a href="../classes/TinCan.ActivityProfile.html">TinCan.ActivityProfile</a></li>
            
                <li><a href="../classes/TinCan.Agent.html">TinCan.Agent</a></li>
            
                <li><a href="../classes/TinCan.AgentAccount.html">TinCan.AgentAccount</a></li>
            
                <li><a href="../classes/TinCan.AgentProfile.html">TinCan.AgentProfile</a></li>
            
                <li><a href="../classes/TinCan.Context.html">TinCan.Context</a></li>
            
                <li><a href="../classes/TinCan.ContextActivities.html">TinCan.ContextActivities</a></li>
            
                <li><a href="../classes/TinCan.Group.html">TinCan.Group</a></li>
            
                <li><a href="../classes/TinCan.InteractionComponent.html">TinCan.InteractionComponent</a></li>
            
                <li><a href="../classes/TinCan.LRS.html">TinCan.LRS</a></li>
            
                <li><a href="../classes/TinCan.Result.html">TinCan.Result</a></li>
            
                <li><a href="../classes/TinCan.Score.html">TinCan.Score</a></li>
            
                <li><a href="../classes/TinCan.State.html">TinCan.State</a></li>
            
                <li><a href="../classes/TinCan.Statement.html">TinCan.Statement</a></li>
            
                <li><a href="../classes/TinCan.StatementRef.html">TinCan.StatementRef</a></li>
            
                <li><a href="../classes/TinCan.StatementsResult.html">TinCan.StatementsResult</a></li>
            
                <li><a href="../classes/TinCan.SubStatement.html">TinCan.SubStatement</a></li>
            
                <li><a href="../classes/TinCan.Utils.html">TinCan.Utils</a></li>
            
                <li><a href="../classes/TinCan.Verb.html">TinCan.Verb</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/TinCan.html">TinCan</a></li>
            
                <li><a href="../modules/TinCan.Activity.html">TinCan.Activity</a></li>
            
                <li><a href="../modules/TinCan.ActivityDefinition.html">TinCan.ActivityDefinition</a></li>
            
                <li><a href="../modules/TinCan.ActivityProfile.html">TinCan.ActivityProfile</a></li>
            
                <li><a href="../modules/TinCan.Agent.html">TinCan.Agent</a></li>
            
                <li><a href="../modules/TinCan.AgentAccount.html">TinCan.AgentAccount</a></li>
            
                <li><a href="../modules/TinCan.AgentProfile.html">TinCan.AgentProfile</a></li>
            
                <li><a href="../modules/TinCan.Context.html">TinCan.Context</a></li>
            
                <li><a href="../modules/TinCan.ContextActivities.html">TinCan.ContextActivities</a></li>
            
                <li><a href="../modules/TinCan.Environment.Browser.html">TinCan.Environment.Browser</a></li>
            
                <li><a href="../modules/TinCan.Environment.Node.html">TinCan.Environment.Node</a></li>
            
                <li><a href="../modules/TinCan.Group.html">TinCan.Group</a></li>
            
                <li><a href="../modules/TinCan.InteractionComponent.html">TinCan.InteractionComponent</a></li>
            
                <li><a href="../modules/TinCan.LRS.html">TinCan.LRS</a></li>
            
                <li><a href="../modules/TinCan.Result.html">TinCan.Result</a></li>
            
                <li><a href="../modules/TinCan.Score.html">TinCan.Score</a></li>
            
                <li><a href="../modules/TinCan.State.html">TinCan.State</a></li>
            
                <li><a href="../modules/TinCan.Statement.html">TinCan.Statement</a></li>
            
                <li><a href="../modules/TinCan.StatementRef.html">TinCan.StatementRef</a></li>
            
                <li><a href="../modules/TinCan.StatementsResult.html">TinCan.StatementsResult</a></li>
            
                <li><a href="../modules/TinCan.SubStatement.html">TinCan.SubStatement</a></li>
            
                <li><a href="../modules/TinCan.Utils.html">TinCan.Utils</a></li>
            
                <li><a href="../modules/TinCan.Verb.html">TinCan.Verb</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: src/TinCan.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/*!
    Copyright 2012 Rustici Software

    Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
*/

/**
TinCan client library

TODO:

* Add statement queueing

@module TinCan
**/
var TinCan;

(function () {
    &quot;use strict&quot;;
    var _reservedQSParams = {
        //
        // these are TC spec reserved words that may end up in queries to the endpoint
        //
        statementId:       true,
        voidedStatementId: true,
        verb:              true,
        object:            true,
        registration:      true,
        context:           true,
        actor:             true,
        since:             true,
        until:             true,
        limit:             true,
        authoritative:     true,
        sparse:            true,
        instructor:        true,
        ascending:         true,
        continueToken:     true,
        agent:             true,
        activityId:        true,
        stateId:           true,
        profileId:         true,

        //
        // these are suggested by the LMS launch spec addition that TinCanJS consumes
        //
        activity_platform: true,
        grouping:          true,
        &quot;Accept-Language&quot;: true
    };

    /**
    @class TinCan
    @constructor
    @param {Object} [options] Configuration used to initialize.
        @param {String} [options.url] URL for determining launch provided
            configuration options
        @param {Array} [options.recordStores] list of pre-configured LRSes
        @param {Object|TinCan.Agent} [options.actor] default actor
        @param {Object|TinCan.Activity} [options.activity] default activity
        @param {String} [options.registration] default registration
        @param {Object|TinCan.Context} [options.context] default context
    **/
    TinCan = function (cfg) {
        this.log(&quot;constructor&quot;);

        /**
        @property recordStores
        @type Array
        */
        this.recordStores = [];

        /**
        Default actor used when preparing statements that
        don&#x27;t yet have an actor set, and for saving state, etc.

        @property actor
        @type Object
        */
        this.actor = null;

        /**
        Default activity, may be used as a statement &#x27;target&#x27;
        or incorporated into &#x27;context&#x27;

        @property activity
        @type Object
        */
        this.activity = null;

        /**
        Default registration, included in default context when
        provided, otherwise used in statement queries

        @property registration
        @type String
        */
        this.registration = null;

        /**
        Default context used when preparing statements that
        don&#x27;t yet have a context set, or mixed in when one
        has been provided, properties do NOT override on mixing

        @property context
        @type Object
        */
        this.context = null;

        this.init(cfg);
    };

    TinCan.prototype = {
        LOG_SRC: &quot;TinCan&quot;,

        /**
        Safe version of logging, only displays when .DEBUG is true, and console.log
        is available

        @method log
        @param {String} msg Message to output
        */
        log: function (msg, src) {
            if (TinCan.DEBUG &amp;&amp; typeof console !== &quot;undefined&quot; &amp;&amp; console.log) {
                src = src || this.LOG_SRC || &quot;TinCan&quot;;

                console.log(&quot;TinCan.&quot; + src + &#x27;: &#x27; + msg);
            }
        },

        /**
        @method init
        @param {Object} [options] Configuration used to initialize (see TinCan constructor).
        */
        init: function (cfg) {
            this.log(&quot;init&quot;);
            var i;

            cfg = cfg || {};

            if (cfg.hasOwnProperty(&quot;url&quot;) &amp;&amp; cfg.url !== &quot;&quot;) {
                this._initFromQueryString(cfg.url);
            }

            if (cfg.hasOwnProperty(&quot;recordStores&quot;) &amp;&amp; cfg.recordStores !== undefined) {
                for (i = 0; i &lt; cfg.recordStores.length; i += 1) {
                    this.addRecordStore(cfg.recordStores[i]);
                }
            }
            if (cfg.hasOwnProperty(&quot;activity&quot;)) {
                if (cfg.activity instanceof TinCan.Activity) {
                    this.activity = cfg.activity;
                }
                else {
                    this.activity = new TinCan.Activity (cfg.activity);
                }
            }
            if (cfg.hasOwnProperty(&quot;actor&quot;)) {
                if (cfg.actor instanceof TinCan.Agent) {
                    this.actor = cfg.actor;
                }
                else {
                    this.actor = new TinCan.Agent (cfg.actor);
                }
            }
            if (cfg.hasOwnProperty(&quot;context&quot;)) {
                if (cfg.context instanceof TinCan.Context) {
                    this.context = cfg.context;
                }
                else {
                    this.context = new TinCan.Context (cfg.context);
                }
            }
            if (cfg.hasOwnProperty(&quot;registration&quot;)) {
                this.registration = cfg.registration;
            }
        },

        /**
        @method _initFromQueryString
        @param {String} url
        @private
        */
        _initFromQueryString: function (url) {
            this.log(&quot;_initFromQueryString&quot;);

            var i,
                prop,
                qsParams = TinCan.Utils.parseURL(url).params,
                lrsProps = [&quot;endpoint&quot;, &quot;auth&quot;],
                lrsCfg = {},
                activityCfg,
                contextCfg,
                extended = null
            ;

            if (qsParams.hasOwnProperty(&quot;actor&quot;)) {
                this.log(&quot;_initFromQueryString - found actor: &quot; + qsParams.actor);
                try {
                    this.actor = TinCan.Agent.fromJSON(qsParams.actor);
                    delete qsParams.actor;
                }
                catch (ex) {
                    this.log(&quot;_initFromQueryString - failed to set actor: &quot; + ex);
                }
            }

            if (qsParams.hasOwnProperty(&quot;activity_id&quot;)) {
                this.activity = new TinCan.Activity (
                    {
                        id: qsParams.activity_id
                    }
                );
                delete qsParams.activity_id;
            }

            if (
                qsParams.hasOwnProperty(&quot;activity_platform&quot;)
                ||
                qsParams.hasOwnProperty(&quot;registration&quot;)
                ||
                qsParams.hasOwnProperty(&quot;grouping&quot;)
            ) {
                contextCfg = {};

                if (qsParams.hasOwnProperty(&quot;activity_platform&quot;)) {
                    contextCfg.platform = qsParams.activity_platform;
                    delete qsParams.activity_platform;
                }
                if (qsParams.hasOwnProperty(&quot;registration&quot;)) {
                    //
                    // stored in two locations cause we always want it in the default
                    // context, but we also want to be able to get to it for Statement
                    // queries
                    //
                    contextCfg.registration = this.registration = qsParams.registration;
                    delete qsParams.registration;
                }
                if (qsParams.hasOwnProperty(&quot;grouping&quot;)) {
                    contextCfg.contextActivities = {};
                    contextCfg.contextActivities.grouping = qsParams.grouping;
                    delete qsParams.grouping;
                }

                this.context = new TinCan.Context (contextCfg);
            }

            //
            // order matters here, process the URL provided LRS last because it gets
            // all the remaining parameters so that they get passed through
            //
            if (qsParams.hasOwnProperty(&quot;endpoint&quot;)) {
                for (i = 0; i &lt; lrsProps.length; i += 1) {
                    prop = lrsProps[i];
                    if (qsParams.hasOwnProperty(prop)) {
                        lrsCfg[prop] = qsParams[prop];
                        delete qsParams[prop];
                    }
                }

                // remove our reserved params so they don&#x27;t end up  in the extended object
                for (i in qsParams) {
                    if (qsParams.hasOwnProperty(i)) {
                        if (_reservedQSParams.hasOwnProperty(i)) {
                            delete qsParams[i];
                        } else {
                            extended = extended || {};
                            extended[i] = qsParams[i];
                        }
                    }
                }
                if (extended !== null) {
                    lrsCfg.extended = extended;
                }

                lrsCfg.allowFail = false;

                this.addRecordStore(lrsCfg);
            }
        },

        /**
        @method addRecordStore
        @param {Object} Configuration data

         * TODO:
         * check endpoint for trailing &#x27;/&#x27;
         * check for unique endpoints
        */
        addRecordStore: function (cfg) {
            this.log(&quot;addRecordStore&quot;);
            var lrs;
            if (cfg instanceof TinCan.LRS) {
                lrs = cfg;
            }
            else {
                lrs = new TinCan.LRS (cfg);
            }
            this.recordStores.push(lrs);
        },

        /**
        @method prepareStatement
        @param {Object|TinCan.Statement} Base statement properties or
            pre-created TinCan.Statement instance
        @return {TinCan.Statement}
        */
        prepareStatement: function (stmt) {
            this.log(&quot;prepareStatement&quot;);
            if (! (stmt instanceof TinCan.Statement)) {
                stmt = new TinCan.Statement (stmt);
            }

            if (stmt.actor === null &amp;&amp; this.actor !== null) {
                stmt.actor = this.actor;
            }
            if (stmt.target === null &amp;&amp; this.activity !== null) {
                stmt.target = this.activity;
            }

            if (this.context !== null) {
                if (stmt.context === null) {
                    stmt.context = this.context;
                }
                else {
                    if (stmt.context.registration === null) {
                        stmt.context.registration = this.context.registration;
                    }
                    if (stmt.context.platform === null) {
                        stmt.context.platform = this.context.platform;
                    }

                    if (this.context.contextActivities !== null) {
                        if (stmt.context.contextActivities === null) {
                            stmt.context.contextActivities = this.context.contextActivities;
                        }
                        else {
                            if (this.context.contextActivities.grouping !== null &amp;&amp; stmt.context.contextActivities.grouping === null) {
                                stmt.context.contextActivities.grouping = this.context.contextActivities.grouping;
                            }
                            if (this.context.contextActivities.parent !== null &amp;&amp; stmt.context.contextActivities.parent === null) {
                                stmt.context.contextActivities.parent = this.context.contextActivities.parent;
                            }
                            if (this.context.contextActivities.other !== null &amp;&amp; stmt.context.contextActivities.other === null) {
                                stmt.context.contextActivities.other = this.context.contextActivities.other;
                            }
                        }
                    }
                }
            }

            return stmt;
        },

        /**
        Calls saveStatement on each configured LRS, provide callback to make it asynchronous

        @method sendStatement
        @param {TinCan.Statement|Object} statement Send statement to LRS
        @param {Function} [callback] Callback function to execute on completion
        */
        sendStatement: function (stmt, callback) {
            this.log(&quot;sendStatement&quot;);

            // would prefer to use .bind instead of &#x27;self&#x27;
            var self = this,
                lrs,
                statement = this.prepareStatement(stmt),
                rsCount = this.recordStores.length,
                i,
                results = [],
                callbackWrapper,
                callbackResults = []
            ;

            if (rsCount &gt; 0) {
                /*
                   if there is a callback that is a function then we need
                   to wrap that function with a function that becomes
                   the new callback that reduces a closure count of the
                   requests that don&#x27;t have allowFail set to true and
                   when that number hits zero then the original callback
                   is executed
                */
                if (typeof callback === &quot;function&quot;) {
                    callbackWrapper = function (err, xhr) {
                        var args;

                        self.log(&quot;sendStatement - callbackWrapper: &quot; + rsCount);
                        if (rsCount &gt; 1) {
                            rsCount -= 1;
                            callbackResults.push(
                                {
                                    err: err,
                                    xhr: xhr
                                }
                            );
                        }
                        else if (rsCount === 1) {
                            callbackResults.push(
                                {
                                    err: err,
                                    xhr: xhr
                                }
                            );
                            args = [
                                callbackResults,
                                statement
                            ];
                            callback.apply(this, args);
                        }
                        else {
                            self.log(&quot;sendStatement - unexpected record store count: &quot; + rsCount);
                        }
                    };
                }

                for (i = 0; i &lt; rsCount; i += 1) {
                    lrs = this.recordStores[i];

                    results.push(
                        lrs.saveStatement(statement, { callback: callbackWrapper })
                    );
                }
            }
            else {
                this.log(&quot;[warning] sendStatement: No LRSs added yet (statement not sent)&quot;);
                if (typeof callback === &quot;function&quot;) {
                    callback.apply(this, [ null, statement ]);
                }
            }

            return {
                statement: statement,
                results: results
            };
        },

        /**
        Calls retrieveStatement on the first LRS, provide callback to make it asynchronous

        @method getStatement
        @param {String} statement Statement ID to get
        @param {Function} [callback] Callback function to execute on completion
        @return {Array|Result} Array of results, or single result

        TODO: make TinCan track statements it has seen in a local cache to be returned easily
        */
        getStatement: function (stmtId, callback) {
            this.log(&quot;getStatement&quot;);

            var lrs;

            if (this.recordStores.length &gt; 0) {
                //
                // for statements (for now) we only need to read from the first LRS
                // in the future it may make sense to get all from all LRSes and
                // compare to remove duplicates or allow inspection of them for differences?
                //
                // TODO: make this the first non-allowFail LRS but for now it should
                // be good enough to make it the first since we know the LMS provided
                // LRS is the first
                //
                lrs = this.recordStores[0];

                return lrs.retrieveStatement(stmtId, { callback: callback });
            }

            this.log(&quot;[warning] getStatement: No LRSs added yet (statement not retrieved)&quot;);
        },

        /**
        Creates a statement used for voiding the passed statement/statement ID and calls
        send statement with the voiding statement.

        @method voidStatement
        @param {TinCan.Statement|String} statement Statement or statement ID to void
        @param {Function} [callback] Callback function to execute on completion
        @param {Object} [options] Options used to build voiding statement
            @param {TinCan.Agent} [options.actor] Agent to be used as &#x27;actor&#x27; in voiding statement
        */
        voidStatement: function (stmt, callback, options) {
            this.log(&quot;voidStatement&quot;);

            // would prefer to use .bind instead of &#x27;self&#x27;
            var self = this,
                lrs,
                actor,
                voidingStatement,
                rsCount = this.recordStores.length,
                i,
                results = [],
                callbackWrapper,
                callbackResults = []
            ;

            if (stmt instanceof TinCan.Statement) {
                stmt = stmt.id;
            }

            if (typeof options.actor !== &quot;undefined&quot;) {
                actor = options.actor;
            }
            else if (this.actor !== null) {
                actor = this.actor;
            }

            voidingStatement = new TinCan.Statement(
                {
                    actor: actor,
                    verb: {
                       id: &quot;http://adlnet.gov/expapi/verbs/voided&quot;
                    },
                    target: {
                        objectType: &quot;StatementRef&quot;,
                        id: stmt
                    }
                }
            );

            if (rsCount &gt; 0) {
                /*
                   if there is a callback that is a function then we need
                   to wrap that function with a function that becomes
                   the new callback that reduces a closure count of the
                   requests that don&#x27;t have allowFail set to true and
                   when that number hits zero then the original callback
                   is executed
                */
                if (typeof callback === &quot;function&quot;) {
                    callbackWrapper = function (err, xhr) {
                        var args;

                        self.log(&quot;voidStatement - callbackWrapper: &quot; + rsCount);
                        if (rsCount &gt; 1) {
                            rsCount -= 1;
                            callbackResults.push(
                                {
                                    err: err,
                                    xhr: xhr
                                }
                            );
                        }
                        else if (rsCount === 1) {
                            callbackResults.push(
                                {
                                    err: err,
                                    xhr: xhr
                                }
                            );
                            args = [
                                callbackResults,
                                voidingStatement
                            ];
                            callback.apply(this, args);
                        }
                        else {
                            self.log(&quot;voidStatement - unexpected record store count: &quot; + rsCount);
                        }
                    };
                }

                for (i = 0; i &lt; rsCount; i += 1) {
                    lrs = this.recordStores[i];

                    results.push(
                        lrs.saveStatement(voidingStatement, { callback: callbackWrapper })
                    );
                }
            }
            else {
                this.log(&quot;[warning] voidStatement: No LRSs added yet (statement not sent)&quot;);
                if (typeof callback === &quot;function&quot;) {
                    callback.apply(this, [ null, voidingStatement ]);
                }
            }

            return {
                statement: voidingStatement,
                results: results
            };
        },

        /**
        Calls retrieveVoidedStatement on the first LRS, provide callback to make it asynchronous

        @method getVoidedStatement
        @param {String} statement Statement ID to get
        @param {Function} [callback] Callback function to execute on completion
        @return {Array|Result} Array of results, or single result

        TODO: make TinCan track voided statements it has seen in a local cache to be returned easily
        */
        getVoidedStatement: function (stmtId, callback) {
            this.log(&quot;getVoidedStatement&quot;);

            var lrs;

            if (this.recordStores.length &gt; 0) {
                //
                // for statements (for now) we only need to read from the first LRS
                // in the future it may make sense to get all from all LRSes and
                // compare to remove duplicates or allow inspection of them for differences?
                //
                // TODO: make this the first non-allowFail LRS but for now it should
                // be good enough to make it the first since we know the LMS provided
                // LRS is the first
                //
                lrs = this.recordStores[0];

                return lrs.retrieveVoidedStatement(stmtId, { callback: callback });
            }

            this.log(&quot;[warning] getVoidedStatement: No LRSs added yet (statement not retrieved)&quot;);
        },

        /**
        Calls saveStatements with list of prepared statements

        @method sendStatements
        @param {Array} Array of statements to send
        @param {Function} Callback function to execute on completion
        */
        sendStatements: function (stmts, callback) {
            this.log(&quot;sendStatements&quot;);
            var self = this,
                lrs,
                statements = [],
                rsCount = this.recordStores.length,
                i,
                results = [],
                callbackWrapper,
                callbackResults = []
            ;
            if (stmts.length === 0) {
                if (typeof callback === &quot;function&quot;) {
                    callback.apply(this, [ null, statements ]);
                }
            }
            else {
                for (i = 0; i &lt; stmts.length; i += 1) {
                    statements.push(
                        this.prepareStatement(stmts[i])
                    );
                }

                if (rsCount &gt; 0) {
                    /*
                       if there is a callback that is a function then we need
                       to wrap that function with a function that becomes
                       the new callback that reduces a closure count of the
                       requests that don&#x27;t have allowFail set to true and
                       when that number hits zero then the original callback
                       is executed
                    */

                    if (typeof callback === &quot;function&quot;) {
                        callbackWrapper = function (err, xhr) {
                            var args;

                            self.log(&quot;sendStatements - callbackWrapper: &quot; + rsCount);
                            if (rsCount &gt; 1) {
                                rsCount -= 1;
                                callbackResults.push(
                                    {
                                        err: err,
                                        xhr: xhr
                                    }
                                );
                            }
                            else if (rsCount === 1) {
                                callbackResults.push(
                                    {
                                        err: err,
                                        xhr: xhr
                                    }
                                );
                                args = [
                                    callbackResults,
                                    statements
                                ];
                                callback.apply(this, args);
                            }
                            else {
                                self.log(&quot;sendStatements - unexpected record store count: &quot; + rsCount);
                            }
                        };
                    }

                    for (i = 0; i &lt; rsCount; i += 1) {
                        lrs = this.recordStores[i];

                        results.push(
                            lrs.saveStatements(statements, { callback: callbackWrapper })
                        );
                    }
                }
                else {
                    this.log(&quot;[warning] sendStatements: No LRSs added yet (statements not sent)&quot;);
                    if (typeof callback === &quot;function&quot;) {
                        callback.apply(this, [ null, statements ]);
                    }
                }
            }

            return {
                statements: statements,
                results: results
            };
        },

        /**
        @method getStatements
        @param {Object} [cfg] Configuration for request
            @param {Boolean} [cfg.sendActor] Include default actor in query params
            @param {Boolean} [cfg.sendActivity] Include default activity in query params
            @param {Object} [cfg.params] Parameters used to filter

            @param {Function} [cfg.callback] Function to run at completion

        TODO: support multiple LRSs and flag to use single
        */
        getStatements: function (cfg) {
            this.log(&quot;getStatements&quot;);
            var queryCfg = {},
                lrs,
                params
            ;
            if (this.recordStores.length &gt; 0) {
                //
                // for get (for now) we only get from one (as they should be the same)
                // but it may make sense to long term try to merge statements, perhaps
                // by using statementId as unique
                //
                // TODO: make this the first non-allowFail LRS but for now it should
                // be good enough to make it the first since we know the LMS provided
                // LRS is the first
                //
                lrs = this.recordStores[0];

                cfg = cfg || {};

                // TODO: need a clone function?
                params = cfg.params || {};

                if (cfg.sendActor &amp;&amp; this.actor !== null) {
                    if (lrs.version === &quot;0.9&quot; || lrs.version === &quot;0.95&quot;) {
                        params.actor = this.actor;
                    }
                    else {
                        params.agent = this.actor;
                    }
                }
                if (cfg.sendActivity &amp;&amp; this.activity !== null) {
                    if (lrs.version === &quot;0.9&quot; || lrs.version === &quot;0.95&quot;) {
                        params.target = this.activity;
                    }
                    else {
                        params.activity = this.activity;
                    }
                }
                if (typeof params.registration === &quot;undefined&quot; &amp;&amp; this.registration !== null) {
                    params.registration = this.registration;
                }

                queryCfg = {
                    params: params
                };
                if (typeof cfg.callback !== &quot;undefined&quot;) {
                    queryCfg.callback = cfg.callback;
                }

                return lrs.queryStatements(queryCfg);
            }

            this.log(&quot;[warning] getStatements: No LRSs added yet (statements not read)&quot;);
        },

        /**
        @method getState
        @param {String} key Key to retrieve from the state
        @param {Object} [cfg] Configuration for request
            @param {Object} [cfg.agent] Agent used in query,
                defaults to &#x27;actor&#x27; property if empty
            @param {Object} [cfg.activity] Activity used in query,
                defaults to &#x27;activity&#x27; property if empty
            @param {Object} [cfg.registration] Registration used in query,
                defaults to &#x27;registration&#x27; property if empty
            @param {Function} [cfg.callback] Function to run with state
        */
        getState: function (key, cfg) {
            this.log(&quot;getState&quot;);
            var queryCfg,
                lrs
            ;

            if (this.recordStores.length &gt; 0) {
                //
                // for state (for now) we are only going to store to the first LRS
                // so only get from there too
                //
                // TODO: make this the first non-allowFail LRS but for now it should
                // be good enough to make it the first since we know the LMS provided
                // LRS is the first
                //
                lrs = this.recordStores[0];

                cfg = cfg || {};

                queryCfg = {
                    agent: (typeof cfg.agent !== &quot;undefined&quot; ? cfg.agent : this.actor),
                    activity: (typeof cfg.activity !== &quot;undefined&quot; ? cfg.activity : this.activity)
                };
                if (typeof cfg.registration !== &quot;undefined&quot;) {
                    queryCfg.registration = cfg.registration;
                }
                else if (this.registration !== null) {
                    queryCfg.registration = this.registration;
                }
                if (typeof cfg.callback !== &quot;undefined&quot;) {
                    queryCfg.callback = cfg.callback;
                }

                return lrs.retrieveState(key, queryCfg);
            }

            this.log(&quot;[warning] getState: No LRSs added yet (state not retrieved)&quot;);
        },

        /**
        @method setState
        @param {String} key Key to store into the state
        @param {String|Object} val Value to store into the state, objects will be stringified to JSON
        @param {Object} [cfg] Configuration for request
            @param {Object} [cfg.agent] Agent used in query,
                defaults to &#x27;actor&#x27; property if empty
            @param {Object} [cfg.activity] Activity used in query,
                defaults to &#x27;activity&#x27; property if empty
            @param {Object} [cfg.registration] Registration used in query,
                defaults to &#x27;registration&#x27; property if empty
            @param {String} [cfg.lastSHA1] SHA1 of the previously seen existing state
            @param {String} [cfg.contentType] Content-Type to specify in headers
            @param {Function} [cfg.callback] Function to run with state
        */
        setState: function (key, val, cfg) {
            this.log(&quot;setState&quot;);
            var queryCfg,
                lrs
            ;

            if (this.recordStores.length &gt; 0) {
                //
                // for state (for now) we are only going to store to the first LRS
                // so only get from there too
                //
                // TODO: make this the first non-allowFail LRS but for now it should
                // be good enough to make it the first since we know the LMS provided
                // LRS is the first
                //
                lrs = this.recordStores[0];

                cfg = cfg || {};

                queryCfg = {
                    agent: (typeof cfg.agent !== &quot;undefined&quot; ? cfg.agent : this.actor),
                    activity: (typeof cfg.activity !== &quot;undefined&quot; ? cfg.activity : this.activity)
                };
                if (typeof cfg.registration !== &quot;undefined&quot;) {
                    queryCfg.registration = cfg.registration;
                }
                else if (this.registration !== null) {
                    queryCfg.registration = this.registration;
                }
                if (typeof cfg.lastSHA1 !== &quot;undefined&quot;) {
                    queryCfg.lastSHA1 = cfg.lastSHA1;
                }
                if (typeof cfg.contentType !== &quot;undefined&quot;) {
                    queryCfg.contentType = cfg.contentType;
                }
                if (typeof cfg.callback !== &quot;undefined&quot;) {
                    queryCfg.callback = cfg.callback;
                }

                return lrs.saveState(key, val, queryCfg);
            }

            this.log(&quot;[warning] setState: No LRSs added yet (state not saved)&quot;);
        },

        /**
        @method deleteState
        @param {String|null} key Key to remove from the state, or null to clear all
        @param {Object} [cfg] Configuration for request
            @param {Object} [cfg.agent] Agent used in query,
                defaults to &#x27;actor&#x27; property if empty
            @param {Object} [cfg.activity] Activity used in query,
                defaults to &#x27;activity&#x27; property if empty
            @param {Object} [cfg.registration] Registration used in query,
                defaults to &#x27;registration&#x27; property if empty
            @param {Function} [cfg.callback] Function to run with state
        */
        deleteState: function (key, cfg) {
            this.log(&quot;deleteState&quot;);
            var queryCfg,
                lrs
            ;

            if (this.recordStores.length &gt; 0) {
                //
                // for state (for now) we are only going to store to the first LRS
                // so only get from there too
                //
                // TODO: make this the first non-allowFail LRS but for now it should
                // be good enough to make it the first since we know the LMS provided
                // LRS is the first
                //
                lrs = this.recordStores[0];

                cfg = cfg || {};

                queryCfg = {
                    agent: (typeof cfg.agent !== &quot;undefined&quot; ? cfg.agent : this.actor),
                    activity: (typeof cfg.activity !== &quot;undefined&quot; ? cfg.activity : this.activity)
                };
                if (typeof cfg.registration !== &quot;undefined&quot;) {
                    queryCfg.registration = cfg.registration;
                }
                else if (this.registration !== null) {
                    queryCfg.registration = this.registration;
                }
                if (typeof cfg.callback !== &quot;undefined&quot;) {
                    queryCfg.callback = cfg.callback;
                }

                return lrs.dropState(key, queryCfg);
            }

            this.log(&quot;[warning] deleteState: No LRSs added yet (state not deleted)&quot;);
        },

        /**
        @method getActivityProfile
        @param {String} key Key to retrieve from the profile
        @param {Object} [cfg] Configuration for request
            @param {Object} [cfg.activity] Activity used in query,
                defaults to &#x27;activity&#x27; property if empty
            @param {Function} [cfg.callback] Function to run with activity profile
        */
        getActivityProfile: function (key, cfg) {
            this.log(&quot;getActivityProfile&quot;);
            var queryCfg,
                lrs
            ;

            if (this.recordStores.length &gt; 0) {
                //
                // for activity profiles (for now) we are only going to store to the first LRS
                // so only get from there too
                //
                // TODO: make this the first non-allowFail LRS but for now it should
                // be good enough to make it the first since we know the LMS provided
                // LRS is the first
                //
                lrs = this.recordStores[0];

                cfg = cfg || {};

                queryCfg = {
                    activity: (typeof cfg.activity !== &quot;undefined&quot; ? cfg.activity : this.activity)
                };
                if (typeof cfg.callback !== &quot;undefined&quot;) {
                    queryCfg.callback = cfg.callback;
                }

                return lrs.retrieveActivityProfile(key, queryCfg);
            }

            this.log(&quot;[warning] getActivityProfile: No LRSs added yet (activity profile not retrieved)&quot;);
        },

        /**
        @method setActivityProfile
        @param {String} key Key to store into the activity profile
        @param {String|Object} val Value to store into the activity profile, objects will be stringified to JSON
        @param {Object} [cfg] Configuration for request
            @param {Object} [cfg.activity] Activity used in query,
                defaults to &#x27;activity&#x27; property if empty
            @param {String} [cfg.lastSHA1] SHA1 of the previously seen existing profile
            @param {String} [cfg.contentType] Content-Type to specify in headers
            @param {Function} [cfg.callback] Function to run with activity profile
        */
        setActivityProfile: function (key, val, cfg) {
            this.log(&quot;setActivityProfile&quot;);
            var queryCfg,
                lrs
            ;

            if (this.recordStores.length &gt; 0) {
                //
                // for activity profile (for now) we are only going to store to the first LRS
                // so only get from there too
                //
                // TODO: make this the first non-allowFail LRS but for now it should
                // be good enough to make it the first since we know the LMS provided
                // LRS is the first
                //
                lrs = this.recordStores[0];

                cfg = cfg || {};

                queryCfg = {
                    activity: (typeof cfg.activity !== &quot;undefined&quot; ? cfg.activity : this.activity)
                };
                if (typeof cfg.callback !== &quot;undefined&quot;) {
                    queryCfg.callback = cfg.callback;
                }
                if (typeof cfg.lastSHA1 !== &quot;undefined&quot;) {
                    queryCfg.lastSHA1 = cfg.lastSHA1;
                }
                if (typeof cfg.contentType !== &quot;undefined&quot;) {
                    queryCfg.contentType = cfg.contentType;
                }

                return lrs.saveActivityProfile(key, val, queryCfg);
            }

            this.log(&quot;[warning] setActivityProfile: No LRSs added yet (activity profile not saved)&quot;);
        },

        /**
        @method deleteActivityProfile
        @param {String|null} key Key to remove from the activity profile, or null to clear all
        @param {Object} [cfg] Configuration for request
            @param {Object} [cfg.activity] Activity used in query,
                defaults to &#x27;activity&#x27; property if empty
            @param {Function} [cfg.callback] Function to run with activity profile
        */
        deleteActivityProfile: function (key, cfg) {
            this.log(&quot;deleteActivityProfile&quot;);
            var queryCfg,
                lrs
            ;

            if (this.recordStores.length &gt; 0) {
                //
                // for activity profile (for now) we are only going to store to the first LRS
                // so only get from there too
                //
                // TODO: make this the first non-allowFail LRS but for now it should
                // be good enough to make it the first since we know the LMS provided
                // LRS is the first
                //
                lrs = this.recordStores[0];

                cfg = cfg || {};

                queryCfg = {
                    activity: (typeof cfg.activity !== &quot;undefined&quot; ? cfg.activity : this.activity)
                };
                if (typeof cfg.callback !== &quot;undefined&quot;) {
                    queryCfg.callback = cfg.callback;
                }

                return lrs.dropActivityProfile(key, queryCfg);
            }

            this.log(&quot;[warning] deleteActivityProfile: No LRSs added yet (activity profile not deleted)&quot;);
        },

        /**
        @method getAgentProfile
        @param {String} key Key to retrieve from the profile
        @param {Object} [cfg] Configuration for request
            @param {Object} [cfg.agent] Agent used in query,
                defaults to &#x27;actor&#x27; property if empty
            @param {Function} [cfg.callback] Function to run with agent profile
        */
        getAgentProfile: function (key, cfg) {
            this.log(&quot;getAgentProfile&quot;);
            var queryCfg,
                lrs
            ;

            if (this.recordStores.length &gt; 0) {
                //
                // for agent profiles (for now) we are only going to store to the first LRS
                // so only get from there too
                //
                // TODO: make this the first non-allowFail LRS but for now it should
                // be good enough to make it the first since we know the LMS provided
                // LRS is the first
                //
                lrs = this.recordStores[0];

                cfg = cfg || {};

                queryCfg = {
                    agent: (typeof cfg.agent !== &quot;undefined&quot; ? cfg.agent : this.actor)
                };
                if (typeof cfg.callback !== &quot;undefined&quot;) {
                    queryCfg.callback = cfg.callback;
                }

                return lrs.retrieveAgentProfile(key, queryCfg);
            }

            this.log(&quot;[warning] getAgentProfile: No LRSs added yet (agent profile not retrieved)&quot;);
        },

        /**
        @method setAgentProfile
        @param {String} key Key to store into the agent profile
        @param {String|Object} val Value to store into the agent profile, objects will be stringified to JSON
        @param {Object} [cfg] Configuration for request
            @param {Object} [cfg.agent] Agent used in query,
                defaults to &#x27;actor&#x27; property if empty
            @param {String} [cfg.lastSHA1] SHA1 of the previously seen existing profile
            @param {String} [cfg.contentType] Content-Type to specify in headers
            @param {Function} [cfg.callback] Function to run with agent profile
        */
        setAgentProfile: function (key, val, cfg) {
            this.log(&quot;setAgentProfile&quot;);
            var queryCfg,
                lrs
            ;

            if (this.recordStores.length &gt; 0) {
                //
                // for agent profile (for now) we are only going to store to the first LRS
                // so only get from there too
                //
                // TODO: make this the first non-allowFail LRS but for now it should
                // be good enough to make it the first since we know the LMS provided
                // LRS is the first
                //
                lrs = this.recordStores[0];

                cfg = cfg || {};

                queryCfg = {
                    agent: (typeof cfg.agent !== &quot;undefined&quot; ? cfg.agent : this.actor)
                };
                if (typeof cfg.callback !== &quot;undefined&quot;) {
                    queryCfg.callback = cfg.callback;
                }
                if (typeof cfg.lastSHA1 !== &quot;undefined&quot;) {
                    queryCfg.lastSHA1 = cfg.lastSHA1;
                }
                if (typeof cfg.contentType !== &quot;undefined&quot;) {
                    queryCfg.contentType = cfg.contentType;
                }

                return lrs.saveAgentProfile(key, val, queryCfg);
            }

            this.log(&quot;[warning] setAgentProfile: No LRSs added yet (agent profile not saved)&quot;);
        },

        /**
        @method deleteAgentProfile
        @param {String|null} key Key to remove from the agent profile, or null to clear all
        @param {Object} [cfg] Configuration for request
            @param {Object} [cfg.agent] Agent used in query,
                defaults to &#x27;actor&#x27; property if empty
            @param {Function} [cfg.callback] Function to run with agent profile
        */
        deleteAgentProfile: function (key, cfg) {
            this.log(&quot;deleteAgentProfile&quot;);
            var queryCfg,
                lrs
            ;

            if (this.recordStores.length &gt; 0) {
                //
                // for agent profile (for now) we are only going to store to the first LRS
                // so only get from there too
                //
                // TODO: make this the first non-allowFail LRS but for now it should
                // be good enough to make it the first since we know the LMS provided
                // LRS is the first
                //
                lrs = this.recordStores[0];

                cfg = cfg || {};

                queryCfg = {
                    agent: (typeof cfg.agent !== &quot;undefined&quot; ? cfg.agent : this.actor)
                };
                if (typeof cfg.callback !== &quot;undefined&quot;) {
                    queryCfg.callback = cfg.callback;
                }

                return lrs.dropAgentProfile(key, queryCfg);
            }

            this.log(&quot;[warning] deleteAgentProfile: No LRSs added yet (agent profile not deleted)&quot;);
        }
    };

    /**
    @property DEBUG
    @static
    @default false
    */
    TinCan.DEBUG = false;

    /**
    Turn on debug logging

    @method enableDebug
    @static
    */
    TinCan.enableDebug = function () {
        TinCan.DEBUG = true;
    };

    /**
    Turn off debug logging

    @method disableDebug
    @static
    */
    TinCan.disableDebug = function () {
        TinCan.DEBUG = false;
    };

    /**
    @method versions
    @return {Array} Array of supported version numbers
    @static
    */
    TinCan.versions = function () {
        // newest first so we can use the first as the default
        return [
            &quot;1.0.1&quot;,
            &quot;1.0.0&quot;,
            &quot;0.95&quot;,
            &quot;0.9&quot;
        ];
    };

    /*global exports*/
    // Support the CommonJS method for exporting our single global
    if (typeof module === &quot;object&quot;) {
        module.exports = TinCan;
    }
}());

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
